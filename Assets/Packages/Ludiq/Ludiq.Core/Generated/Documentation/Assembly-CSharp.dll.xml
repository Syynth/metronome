<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp.dll</name>
    </assembly>
    <members>
        <member name="T:Cinemachine.CinemachineBlendListCamera">
            <summary>
            This is a virtual camera "manager" that owns and manages a collection
            of child Virtual Cameras.  When the camera goes live, these child vcams 
            are enabled, one after another, holding each camera for a designated time.  
            Blends between cameras are specified.
            The last camera is held indefinitely.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_EnableAllChildCameras">
            <summary>Force all child cameras to be enabled.  This is useful if animating them in Timeline, but consumes extra resources.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this field</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendListCamera.Instruction">
            <summary>This represents a single entry in the instrunction list of the BlendListCamera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_VirtualCamera">
            <summary>The virtual camera to activate when this instruction becomes active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_Hold">
            <summary>How long to wait (in seconds) before activating the next virtual camera in the list (if any)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_Blend">
            <summary>How to blend to the next virtual camera in the list (if any)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_Instructions">
            <summary>The set of instructions associating virtual cameras with states.  
            The set of instructions for enabling child cameras</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the State Driven Camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.State">
            <summary>The State of the current live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Cinemachine.CinemachineBlendListCamera.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)" -->
        <member name="M:Cinemachine.CinemachineBlendListCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.mActivationTime">
            <summary>The time at which the current instruction went live</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.ValidateInstructions">
            <summary>Internal API for the inspector editor.</summary>
            // GML todo: make this private, part of UpdateListOfChildren()
        </member>
        <member name="T:Cinemachine.CinemachineBrain">
            <summary>
            CinemachineBrain is the link between the Unity Camera and the Cinemachine Virtual 
            Cameras in the scene.  It monitors the priority stack to choose the current 
            Virtual Camera, and blend with another if necessary.  Finally and most importantly, 
            it applies the Virtual Camera state to the attached Unity Camera.
            
            The CinemachineBrain is also the place where rules for blending between virtual cameras 
            are defined.  Camera blending is an interpolation over time of one virtual camera 
            position and state to another. If you think of virtual cameras as cameramen, then 
            blending is a little like one cameraman smoothly passing the camera to another cameraman. 
            You can specify the time over which to blend, as well as the blend curve shape. 
            Note that a camera cut is just a zero-time blend.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_ShowDebugText">
            <summary>
            When enabled, the current camera and blend will be indicated in the game window, for debugging.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_ShowCameraFrustum">
            <summary>
            When enabled, shows the camera's frustum in the scene view.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_IgnoreTimeScale">
            <summary>
            When enabled, the cameras will always respond in real-time to user input and damping, 
            even if the game is running in slow motion
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_WorldUpOverride">
            <summary>
            If set, this object's Y axis will define the worldspace Up vector for all the
            virtual cameras.  This is useful in top-down game environments.  If not set, Up is worldspace Y.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.FixedUpdate">
            <summary>Virtual cameras are updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.LateUpdate">
            <summary>Virtual cameras are updated in MonoBehaviour LateUpdate.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate">
            <summary>Virtual cameras are updated according to how the target is updated.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_UpdateMethod">
            <summary>Depending on how the target objects are animated, adjust the update method to
            minimize the potential jitter.  Use FixedUpdate if all your targets are animated with for RigidBody animation.
            SmartUpdate will choose the best method for each virtual camera, depending
            on how the target is animated.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_DefaultBlend">
            <summary>
            The blend which is used if you don't explicitly define a blend between two Virtual Cameras.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CustomBlends">
            <summary>
            This is the asset which contains custom settings for specific blends.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.OutputCamera">
            <summary>
            Get the Unity Camera that is attached to this GameObject.  This is the camera
            that will be controlled by the brain.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.BrainEvent">
            <summary>Event with a CinemachineBrain parameter</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.VcamEvent">
            <summary>Event with a ICinemachineCamera parameter</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CameraCutEvent">
            <summary>This event will fire whenever a virtual camera goes live and there is no blend</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CameraActivatedEvent">
            <summary>This event will fire whenever a virtual camera goes live.  If a blend is involved, 
            then the event will fire on the first frame of the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.PostProcessingComponent">
            <summary>Support for opaque post-processing module</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.sPostProcessingHandler">
            <summary>
            Because the PostProcessing package is not guaranteed to be present,
            we must handle PostFX in this opaque way.  This delegate will be called
            every frame (during LateUpdate) after the camera has been positioned.
            The intention is that the callback will make the right calls to the PostProcessing module.
            Cinemachine provides the CinemachinePostFX behaviour that makes use of this delegate.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.SoloCamera">
            <summary>
            API for the Unity Editor.
            Show this camera no matter what.  This is static, and so affects all Cinemachine brains.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetSoloGUIColor">
            <summary>API for the Unity Editor.</summary>
            <returns>Color used to indicate that a camera is in Solo mode.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.DefaultWorldUp">
            <summary>Get the default world up for the virtual cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetOverrideFrame(System.Int32)">
            Get the override if it's present, else insert it
        </member>
        <member name="F:Cinemachine.CinemachineBrain.mOverrideBlendFromNothing">
            Get the next active blend on the stack.  Used when an override blends in from nothing.
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetActiveOverride">
            Get the first override that has a camera
        </member>
        <member name="M:Cinemachine.CinemachineBrain.SetCameraOverride(System.Int32,Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,System.Single,System.Single)">
            <summary>
            This API is specifically for Timeline.  Do not use it.
            Override the current camera and current blend.  This setting will trump
            any in-game logic that sets virtual camera priorities and Enabled states.
            This is the main API for the timeline.
            </summary>
            <param name="overrideId">Id to represent a specific client.  An internal
            stack is maintained, with the most recent non-empty override taking precenence.
            This id must be > 0.  If you pass -1, a new id will be created, and returned.
            Use that id for subsequent calls.  Don't forget to
            call ReleaseCameraOverride after all overriding is finished, to
            free the OverideStack resources.</param>
            <param name="camA"> The camera to set, corresponding to weight=0</param>
            <param name="camB"> The camera to set, corresponding to weight=1</param>
            <param name="weightB">The blend weight.  0=camA, 1=camB</param>
            <param name="deltaTime">override for deltaTime.  Should be Time.FixedDelta for
            time-based calculations to be included, -1 otherwise</param>
            <returns>The oiverride ID.  Don't forget to call ReleaseCameraOverride
            after all overriding is finished, to free the OverideStack resources.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.ReleaseCameraOverride(System.Int32)">
            <summary>
            This API is specifically for Timeline.  Do not use it.
            Release the resources used for a camera override client.
            See SetCameraOverride.
            </summary>
            <param name="overrideId">The ID to released.  This is the value that
            was returned by SetCameraOverride</param>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.OnPreCull">
            This is only needed in editor mode to force timeline to call OnGUI while
            timeline is up and the game is not running, in order to allow dragging
            the composer guide in the game view.
        </member>
        <member name="P:Cinemachine.CinemachineBrain.IsBlending">
            <summary>
            Is there a blend in progress?
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.ActiveBlend">
            <summary>
            Get the current blend in progress.  Returns null if none.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.IsLive(Cinemachine.ICinemachineCamera)">
            <summary>
            True if the ICinemachineCamera the current active camera,
            or part of a current blend, either directly or indirectly because its parents are live.
            </summary>
            <param name="vcam">The camera to test whether it is live</param>
            <returns>True if the camera is live (directly or indirectly)
            or part of a blend in progress.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.ActiveVirtualCamera">
            <summary>
            Get the current active virtual camera.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.CurrentCameraState">
            <summary>
            The current state applied to the unity camera (may be the result of a blend)
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.TopCameraFromPriorityQueue">
            <summary>
            Get the highest-priority Enabled ICinemachineCamera
            that is visible to my camera.  Culling Mask is used to test visibility.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.LookupBlendCurve(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,System.Single@)">
            <summary>
            Create a blend curve for blending from one ICinemachineCamera to another.
            If there is a specific blend defined for these cameras it will be used, otherwise
            a default blend will be created, which could be a cut.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.CreateBlend(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,UnityEngine.AnimationCurve,System.Single,Cinemachine.CinemachineBlend)">
            <summary>
            Create a blend from one ICinemachineCamera to another,
            or to/from a point, if we can't do anything else
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.PushStateToUnityCamera(Cinemachine.CameraState,Cinemachine.ICinemachineCamera)">
            <summary> Apply a cref="CameraState"/> to the game object</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetSubframeCount">
            <summary>API for CinemachineCore only: Get the number of subframes to
            update the virtual cameras.</summary>
            <returns>Number of subframes registered by the first brain's FixedUpdate</returns>
        </member>
        <member name="T:Cinemachine.StaticPointVirtualCamera">
            <summary>
            Point source for blending. It's not really a virtual camera, but takes
            a CameraState and exposes it as a virtual camera for the purposes of blending.
            </summary>
        </member>
        <member name="T:Cinemachine.BlendSourceVirtualCamera">
            <summary>
            Blend result source for blending.   This exposes a CinemachineBlend object
            as an ersatz virtual camera for the purposes of blending.  This achieves the purpose
            of blending the result oif a blend.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineClearShot">
            <summary>
            Cinemachine ClearShot is a "manager camera" that owns and manages a set of 
            Virtual Camera gameObject children.  When Live, the ClearShot will check the
            children, and choose the one with the best quality shot and make it Live.
            
            This can be a very powerful tool.  If the child cameras have CinemachineCollider 
            extensions, they will analyze the scene for target obstructions, optimal target
            distance, and other items, and report their assessment of shot quality back to 
            the ClearShot parent, who will then choose the best one.  You can use this to set
            up complex multi-camera coverage of a scene, and be assured that a clear shot of 
            the target will always be available.
            
            If multiple child cameras have the same shot quality, the one with the highest 
            priority will be chosen.
            
            You can also define custom blends between the ClearShot children.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this filed.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ActivateAfter">
            <summary>Wait this many seconds before activating a new child camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_MinDuration">
            <summary>An active camera must be active for at least this many seconds</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_RandomizeChoice">
            <summary>If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list order will be used</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_DefaultBlend">
            <summary>The blend which is used if you don't explicitly define a blend between two Virtual Cameras</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_CustomBlends">
            <summary>This is the asset which contains custom settings for specific blends</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the ClearShot camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.State">
            <summary>The CameraState of the currently live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.ResetRandomization">
            <summary>If RandomizeChoice is enabled, call this to re-randomize the children next frame.
            This is useful if you want to freshen up the shot.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>Notification that this virtual camera is going live.
            This implementation resets the child randomization.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="T:Cinemachine.CinemachineCollider">
            <summary>
            An add-on module for Cinemachine Virtual Camera that post-processes
            the final position of the virtual camera. Based on the supplied settings,
            the Collider will attempt to preserve the line of sight
            with the LookAt target of the virtual camera by moving 
            away from objects that will obstruct the view.
            
            Additionally, the Collider can be used to assess the shot quality and 
            report this as a field in the camera State.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_CollideAgainst">
            <summary>The Unity layer mask against which the collider will raycast.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_IgnoreTag">
            <summary>Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_MinimumDistanceFromTarget">
            <summary>Obstacles closer to the target than this will be ignored</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_AvoidObstacles">
            <summary>
            When enabled, will attempt to resolve situations where the line of sight to the 
            target is blocked by an obstacle
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_DistanceLimit">
            <summary>
            The raycast distance to test for when checking if the line of sight to this camera's target is clear.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_CameraRadius">
            <summary>
            Camera will try to maintain this distance from any obstacle.  
            Increase this value if you are seeing inside obstacles due to a large 
            FOV on the camera.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCollider.ResolutionStrategy">
            <summary>The way in which the Collider will attempt to preserve sight of the target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PullCameraForward">
            <summary>Camera will be pulled forward along its Z axis until it is in front of 
            the nearest obstacle</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraHeight">
            <summary>In addition to pulling the camera forward, an effort will be made to 
            return the camera to its original height</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraDistance">
            <summary>In addition to pulling the camera forward, an effort will be made to 
            return the camera to its original distance from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_Strategy">
            <summary>The way in which the Collider will attempt to preserve sight of the target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_MaximumEffort">
            <summary>
            Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.  
            In most environments, 4 is enough.  
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_Damping">
            <summary>
            The gradualness of collision resolution.  Higher numbers will move the 
            camera more gradually away from obstructions.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_OptimalTargetDistance">
            <summary>If greater than zero, a higher score will be given to shots when the target is closer to
            this distance.  Set this to zero to disable this feature</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.IsTargetObscured(Cinemachine.ICinemachineCamera)">
            <summary>See wheter an object is blocking the camera's view of the target</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the collider, in the event that the camera has children</param>
            <returns>True if something is blocking the view</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.CameraWasDisplaced(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>See whether the virtual camera has been moved nby the collider</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the collider, in the event that the camera has children</param>
            <returns>True if the virtual camera has been displaced due to collision or
            target obstruction</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.OnDestroy">
            <summary>Cleanup</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.PrecisionSlush">
            This must be small but greater than 0 - reduces false results due to precision
        </member>
        <member name="P:Cinemachine.CinemachineCollider.DebugPaths">
            <summary>Inspector API for debugging collision resolution path</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callcack to to the collision resolution and shot evaluation</summary>
        </member>
        <member name="T:Cinemachine.CinemachineConfiner">
            <summary>
            An add-on module for Cinemachine Virtual Camera that post-processes
            the final position of the virtual camera. It will confine the virtual
            camera's position to the volume specified in the Bounding Volume field.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineConfiner.Mode">
            <summary>The confiner can operate using a 2D bounding shape or a 3D bounding volume</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_ConfineMode">
            <summary>The confiner can operate using a 2D bounding shape or a 3D bounding volume</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_BoundingVolume">
            <summary>The volume within which the camera is to be contained.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_BoundingShape2D">
            <summary>The 2D shape within which the camera is to be contained.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_ConfineScreenEdges">
            <summary>If camera is orthographic, screen edges will be confined to the volume.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_Damping">
            <summary>How gradually to return the camera to the bounding volume if it goes beyond the borders</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.CameraWasDisplaced(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>See whether the virtual camera has been moved by the confiner</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the confiner, in the event that the camera has children</param>
            <returns>True if the virtual camera has been repositioned</returns>
        </member>
        <member name="P:Cinemachine.CinemachineConfiner.IsValid">
            <summary>Check if the bounding volume is defined</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callback to to the camera confining</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.InvalidatePathCache">
            <summary>Call this if the bounding shape's points change at runtime</summary>
        </member>
        <member name="T:Cinemachine.CinemachineDollyCart">
            <summary>
            This is a very simple behaviour that constrains its transform to a CinemachinePath.  
            It can be used to animate any objects along a path, or as a Follow target for 
            Cinemachine Virtual Cameras.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Path">
            <summary>The path to follow</summary>
        </member>
        <member name="T:Cinemachine.CinemachineDollyCart.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.UpdateMethod.Update">
            <summary>Updated in normal MonoBehaviour Update.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.UpdateMethod.FixedUpdate">
            <summary>Updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_UpdateMethod">
            <summary>When to move the cart, if Velocity is non-zero</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Speed">
            <summary>Move the cart with this speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Position">
            <summary>The cart's current position on the path, in distance units</summary>
        </member>
        <member name="T:Cinemachine.CinemachineExternalCamera">
            <summary>
            This component will expose a non-cinemachine camera to the cinemachine system,
            allowing it to participate in blends.
            Just add it as a component alongside an existing Unity Camera component.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineExternalCamera.m_LookAt">
            <summary>The object that the camera is looking at.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.State">
            <summary>Get the CameraState, as we are able to construct one from the Unity Camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.LookAt">
            <summary>The object that the camera is looking at</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.Follow">
            <summary>This vcam defines no targets</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExternalCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Construct a CameraState object from the Unity Camera</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFollowZoom">
            <summary>
            An add-on module for Cinemachine Virtual Camera that adjusts
            the FOV of the lens to keep the target object at a constant size on the screen,
            regardless of camera and target position.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_Width">
            <summary>The shot width to maintain, in world units, at target distance.
            FOV will be adusted as far as possible to maintain this width at the
            target distance from the camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_Damping">
            <summary>Increase this value to soften the aggressiveness of the follow-zoom.
            Small numbers are more responsive, larger numbers give a more heavy slowly responding camera. </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_MinFOV">
            <summary>Will not generate an FOV smaller than this.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_MaxFOV">
            <summary>Will not generate an FOV larget than this.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFollowZoom.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callback to preform the zoom adjustment</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook">
            <summary>
            A Cinemachine Camera geared towards a 3rd person camera experience.
            The camera orbits around its subject with three separate camera rigs defining
            rings around the target. Each rig has its own radius, height offset, composer,
            and lens settings.
            Depending on the camera's position along the spline connecting these three rigs,
            these settings are interpolated to give the final camera position and state.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_LookAt">
            <summary>Object for the camera children to look at (the aim target)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Follow">
            <summary>Object for the camera children wants to move with (the body target)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_CommonLens">
            <summary>If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will be used</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Lens">
            <summary>Specifies the lens properties of this Virtual Camera.  
            This generally mirrors the Unity Camera's lens settings, and will be used to drive 
            the Unity camera when the vcam is active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_YAxis">
            <summary>The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_XAxis">
            <summary>The Horizontal axis.  Value is 0..359.  This is passed on to the rigs' OrbitalTransposer component</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Heading">
            <summary>The definition of Forward.  Camera will follow behind</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_RecenterToTargetHeading">
            <summary>Controls how automatic recentering of the X axis is accomplished</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_BindingMode">
            <summary>The coordinate space to use when interpreting the offset from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_SplineCurvature">
            <summary></summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.Orbit">
            <summary>Defines the height and radius of the Rig orbit</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.Orbit.m_Height">
            <summary>Height relative to target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.Orbit.m_Radius">
            <summary>Radius of orbit</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.Orbit.#ctor(System.Single,System.Single)">
            <summary>Constructor with specific values</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Orbits">
            <summary>The radius and height of the three orbiting rigs</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.GetRig(System.Int32)">
            <summary>Get a child rig</summary>
            <param name="i">Rig index.  Can be 0, 1, or 2</param>
            <returns>The rig, or null if index is bad.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.RigNames">
            <summary>Names of the 3 child rigs</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnEnable">
            <summary>Updates the child rig cache</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnDestroy">
            <summary>Makes sure that the child rigs get destroyed in an undo-firndly manner.
            Invalidates the rig cache.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnTransformChildrenChanged">
            <summary>Invalidates the rig cache</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.State">
            <summary>The cacmera state, which will be a blend of the child rig states</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.LiveChildOrSelf">
            <summary>Returns the rig with the greatest weight</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.  
            Returns true if the child is currently contributing actively to the camera state.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  All 3 child rigs are updated,
            and a blend calculated, depending on the value of the Y axis.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>If we are transitioning from another FreeLook, grab the axis values from it.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Rigs">
            Serialized in order to support copy/paste
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.CreateRigOverride">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.CreateRigDelegate">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.DestroyRigOverride">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.DestroyRigDelegate">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.GetLocalPositionForCameraFromInput(System.Single)">
            <summary>
            Returns the local position of the camera along the spline used to connect the
            three camera rigs. Does not take into account the current heading of the
            camera (or its target)
            </summary>
            <param name="t">The t-value for the camera on its spline. Internally clamped to
            the value [0,1]</param>
            <returns>The local offset (back + up) of the camera WRT its target based on the
            supplied t-value</returns>
        </member>
        <member name="T:Cinemachine.CinemachineMixingCamera">
            <summary>
            CinemachineMixingCamera is a "manager camera" that takes on the state of 
            the weighted average of the states of its child virtual cameras.
            
            A fixed number of slots are made available for cameras, rather than a dynamic array.  
            We do it this way in order to support weight animation from the Timeline.
            Timeline cannot animate array elements.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.MaxCameras">
            <summary>The maximum number of tracked cameras.  If you want to add 
            more cameras, do it here in the source code, and be sure to add the 
            extra member variables and to make the appropriate changes in 
            GetWeight() and SetWeight().
            The inspector will figure itself out based on this value.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight0">
            <summary>Weight of the first tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight1">
            <summary>Weight of the second tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight2">
            <summary>Weight of the third tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight3">
            <summary>Weight of the fourth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight4">
            <summary>Weight of the fifth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight5">
            <summary>Weight of the sixth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight6">
            <summary>Weight of the seventh tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight7">
            <summary>Weight of the eighth tracked camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.GetWeight(System.Int32)">
            <summary>Get the weight of the child at an index.</summary>
            <param name="index">The child index. Only immediate CinemachineVirtualCameraBase 
            children are counted.</param>
            <returns>The weight of the camera.  Valid only if camera is active and enabled.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.SetWeight(System.Int32,System.Single)">
            <summary>Set the weight of the child at an index.</summary>
            <param name="index">The child index. Only immediate CinemachineVirtualCameraBase 
            children are counted.</param>
            <param name="w">The weight to set.  Can be any non-negative number.</param>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.GetWeight(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>Get the weight of the child CinemachineVirtualCameraBase.</summary>
            <param name="vcam">The child camera.</param>
            <returns>The weight of the camera.  Valid only if camera is active and enabled.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.SetWeight(Cinemachine.CinemachineVirtualCameraBase,System.Single)">
            <summary>Set the weight of the child CinemachineVirtualCameraBase.</summary>
            <param name="vcam">The child camera.</param>
            <param name="w">The weight to set.  Can be any non-negative number.</param>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_State">
            <summary>Blended camera state</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, which is nominally 
            the one with the greatest weight.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.State">
            <summary>The blended CameraState</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LookAt">
            <summary>Not used</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.Follow">
            <summary>Not used</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnValidate">
            <summary>Makes sure the weights are non-negative</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.ChildCameras">
            <summary>Get the cached list of child cameras.  
            These are just the immediate children in the hierarchy.
            Note: only the first entries of this list participate in the 
            final blend, up to MaxCameras</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.InvalidateListOfChildren">
            <summary>Invalidate the cached list of child cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.ValidateListOfChildren">
            <summary>Rebuild the cached list of child cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            computes and caches the weighted blend of the tracked cameras.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="T:Cinemachine.CinemachinePath">
            <summary>Defines a world-space path, consisting of an array of waypoints,
            each of which has position, tangent, and roll settings.  Bezier interpolation
            is performed between the waypoints, to get a smooth and continuous path.</summary>
        </member>
        <member name="T:Cinemachine.CinemachinePath.Waypoint">
            <summary>A waypoint along the path</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.position">
            <summary>Position in path-local space</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.tangent">
            <summary>Offset from the position, which defines the tangent of the curve at the waypoint.  
            The length of the tangent encodes the strength of the bezier handle.  
            The same handle is used symmetrically on both sides of the waypoint, to ensure smoothness.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.roll">
            <summary>Defines the roll of the path at this waypoint.  
            The other orientation axes are inferred from the tangent and world up.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.m_Looped">
            <summary>If checked, then the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.m_Waypoints">
            <summary>The waypoints that define the path.
            They will be interpolated using a bezier curve</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePath.GetBoundingIndices(System.Single,System.Int32@,System.Int32@)">
            <summary>Returns normalized position</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path, as defined by tangent, up, and roll.</returns>
        </member>
        <member name="T:Cinemachine.CinemachinePipeline">
            <summary>
            Internal container for CinemachineComponentBase.  Does nothing but contain.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineSmoothPath">
            <summary>Defines a world-space path, consisting of an array of waypoints,
            each of which has position and roll settings.  Bezier interpolation
            is performed between the waypoints, to get a smooth and continuous path.
            The path will pass through all waypoints, and (unlike CinemachinePath) first 
            and second order continuity is guaranteed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.m_Looped">
            <summary>If checked, then the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="T:Cinemachine.CinemachineSmoothPath.Waypoint">
            <summary>A waypoint along the path</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.Waypoint.position">
            <summary>Position in path-local space</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.Waypoint.roll">
            <summary>Defines the roll of the path at this waypoint.  
            The other orientation axes are inferred from the tangent and world up.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.Waypoint.AsVector4">
            <summary>Representation as Vector4</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.m_Waypoints">
            <summary>The waypoints that define the path.
            They will be interpolated using a bezier curve</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.InvalidateDistanceCache">
            <summary>Call this if the path changes in such a way as to affect distances
            or other cached path elements</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.GetBoundingIndices(System.Single,System.Int32@,System.Int32@)">
            <summary>Returns normalized position</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path, as defined by tangent, up, and roll.</returns>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera">
            <summary>
            This is a virtual camera "manager" that owns and manages a collection
            of child Virtual Cameras.  These child vcams are mapped to individual states in
            an animation state machine, allowing you to associate specific vcams to specific 
            animation states.  When that state is active in the state machine, then the 
            associated camera will be activated.
            
            You can define custom blends and transitions between child cameras.
            
            In order to use this behaviour, you must have an animated target (i.e. an object
            animated with a state machine) to drive the behaviour.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_AnimatedTarget">
            <summary>The state machine whose state changes will drive this camera's choice of active child</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_LayerIndex">
            <summary>Which layer in the target FSM to observe</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_EnableAllChildCameras">
            <summary>Force all child cameras to be enabled.  This is useful if animating them in Timeline, but consumes extra resources.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this field</summary>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera.Instruction">
            <summary>This represents a single instrunction to the StateDrivenCamera.  It associates
            an state from the state machine with a child Virtual Camera, and also holds
            activation tuning parameters.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_FullHash">
            <summary>The full hash of the animation state</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_VirtualCamera">
            <summary>The virtual camera to activate whrn the animation state becomes active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_ActivateAfter">
            <summary>How long to wait (in seconds) before activating the virtual camera. 
            This filters out very short state durations</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_MinDuration">
            <summary>The minimum length of time (in seconds) to keep a virtual camera active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_Instructions">
            <summary>The set of instructions associating virtual cameras with states.  
            These instructions are used to choose the live child at any given moment</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_DefaultBlend">
            <summary>
            The blend which is used if you don't explicitly define a blend between two Virtual Camera children.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_CustomBlends">
            <summary>
            This is the asset which contains custom settings for specific child blends.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera.ParentHash">
            <summary>Internal API for the Inspector editor.  This implements nested states.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.ParentHash.m_Hash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.ParentHash.m_ParentHash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.ParentHash.#ctor(System.Int32,System.Int32)">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ParentHash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the State Driven Camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.State">
            <summary>The State of the current live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.CreateFakeHashName(System.Int32,System.String)">
            <summary>API for the inspector editor.  Animation module does not have hashes
            for state parents, so we have to invent them in order to implement nested state
            handling</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.ValidateInstructions">
            <summary>Internal API for the inspector editor.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup">
            <summary>Defines a group of target objects, each with a radius and a weight.
            The weight is used when calculating the average position of the target group.
            Higher-weighted members of the group will count more.
            The bounding box is calculated by taking the member positions, weight, 
            and radii into account.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.Target">
            <summary>Holds the information that represents a member of the group</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.target">
            <summary>The target objects.  This object's position and orientation will contribute to the 
            group's average position and orientation, in accordance with its weight</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.weight">
            <summary>How much weight to give the target when averaging.  Cannot be negative</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.radius">
            <summary>The radius of the target, used for calculating the bounding box.  Cannot be negative</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.PositionMode">
            <summary>How the group's position is calculated</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.PositionMode.GroupCenter">
            <summary>Group position will be the center of the group's axis-aligned bounding box</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.PositionMode.GroupAverage">
            <summary>Group position will be the weighted average of the positions of the members</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_PositionMode">
            <summary>How the group's position is calculated</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.RotationMode">
            <summary>How the group's orientation is calculated</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.RotationMode.Manual">
            <summary>Manually set in the group's transform</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.RotationMode.GroupAverage">
            <summary>Weighted average of the orientation of its members.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_RotationMode">
            <summary>How the group's orientation is calculated</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.Update">
            <summary>Updated in normal MonoBehaviour Update.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.FixedUpdate">
            <summary>Updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.LateUpdate">
            <summary>Updated in MonoBehaviour LateUpdate.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_UpdateMethod">
            <summary>When to update the group's transform based on the position of the group members</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_Targets">
            <summary>The target objects, together with their weights and radii, that will
            contribute to the group's average position, orientation, and size</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_lastRadius">
            Cache of the last valid radius
        </member>
        <member name="P:Cinemachine.CinemachineTargetGroup.BoundingBox">
            <summary>The axis-aligned bounding box of the group, computed using the
            targets positions and radii</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTargetGroup.IsEmpty">
            <summary>Return true if there are no members with weight > 0</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTargetGroup.GetViewSpaceBoundingBox(UnityEngine.Matrix4x4)">
            <summary>The axis-aligned bounding box of the group, in a specific reference frame</summary>
            <param name="mView">The frame of reference in which to compute the bounding box</param>
            <returns>The axis-aligned bounding box of the group, in the desired frame of reference</returns>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera">
             <summary>
             This behaviour is intended to be attached to an empty Transform GameObject, 
             and it represents a Virtual Camera within the Unity scene.
             
             The Virtual Camera will animate its Transform according to the rules contained
             in its CinemachineComponent pipeline (Aim, Body, and Noise).  When the virtual
             camera is Live, the Unity camera will assume the position and orientation
             of the virtual camera.
             
             A virtual camera is not a camera. Instead, it can be thought of as a camera controller,
             not unlike a cameraman. It can drive the Unity Camera and control its position, 
             orientation, lens settings, and PostProcessing effects. Each Virtual Camera owns 
             its own Cinemachine Component Pipeline, through which you provide the instructions 
             for dynamically tracking specific game objects. 
             
             A virtual camera is very lightweight, and does no rendering of its own. It merely 
             tracks interesting GameObjects, and positions itself accordingly. A typical game 
             can have dozens of virtual cameras, each set up to follow a particular character 
             or capture a particular event. 
             
             A Virtual Camera can be in any of three states: 
             
             * **Live**: The virtual camera is actively controlling the Unity Camera. The 
             virtual camera is tracking its targets and being updated every frame. 
             * **Standby**: The virtual camera is tracking its targets and being updated 
             every frame, but no Unity Camera is actively being controlled by it. This is 
             the state of a virtual camera that is enabled in the scene but perhaps at a 
             lower priority than the Live virtual camera. 
             * **Disabled**: The virtual camera is present but disabled in the scene. It is 
             not actively tracking its targets and so consumes no processing power. However, 
             the virtual camera can be made live from the Timeline. 
             
             The Unity Camera can be driven by any virtual camera in the scene. The game 
             logic can choose the virtual camera to make live by manipulating the virtual 
             cameras' enabled flags and their priorities, based on game logic. 
            
             In order to be driven by a virtual camera, the Unity Camera must have a CinemachineBrain 
             behaviour, which will select the most eligible virtual camera based on its priority 
             or on other criteria, and will manage blending. 
             </summary>
             <seealso cref="T:Cinemachine.CinemachineVirtualCameraBase"/>
             <seealso cref="T:Cinemachine.LensSettings"/>
             <seealso cref="T:Cinemachine.CinemachineComposer"/>
             <seealso cref="T:Cinemachine.CinemachineTransposer"/>
             <seealso cref="T:Cinemachine.CinemachineBasicMultiChannelPerlin"/>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_LookAt">
            <summary>The object that the camera wants to look at (the Aim target).
            The Aim component of the CinemachineComponent pipeline
            will refer to this target and orient the vcam in accordance with rules and
            settings that are provided to it.
            If this is null, then the vcam's Transform orientation will be used.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_Follow">
            <summary>The object that the camera wants to move with (the Body target).
            The Body component of the CinemachineComponent pipeline
            will refer to this target and position the vcam in accordance with rules and
            settings that are provided to it.
            If this is null, then the vcam's Transform position will be used.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_Lens">
            <summary>Specifies the LensSettings of this Virtual Camera.
            These settings will be transferred to the Unity camera when the vcam is live.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.PipelineName">
            <summary>This is the name of the hidden GameObject that will be created as a child object
            of the virtual camera.  This hidden game object acts as a container for the polymorphic
            CinemachineComponent pipeline.  The Inspector UI for the Virtual Camera
            provides access to this pipleline, as do the CinemachineComponent-family of
            public methods in this class.
            The lifecycle of the pipeline GameObject is managed automatically.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.State">
            <summary>The CameraState object holds all of the information
            necessary to position the Unity camera.  It is the output of this class.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.LookAt">
            <summary>Get the LookAt target for the Aim component in the CinemachinePipeline.
            If this vcam is a part of a meta-camera collection, then the owner's target
            will be used if the local target is null.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.Follow">
            <summary>Get the Follow target for the Body component in the CinemachinePipeline.
            If this vcam is a part of a meta-camera collection, then the owner's target
            will be used if the local target is null.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at LateUpdate time
            so the vcam can position itself and track its targets.  This class will
            invoke its pipeline and generate a CameraState for this frame.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnEnable">
            <summary>Make sure that the pipeline cache is up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnDestroy">
            <summary>Calls the DestroyPipelineDelegate for destroying the hidden
            child object, to support undo.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.CreatePipelineOverride">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera.CreatePipelineDelegate">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in
            the CinemachineVirtualCamera class.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.DestroyPipelineOverride">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera.DestroyPipelineDelegate">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.DestroyPipeline">
            <summary>Destroy any existing pipeline container.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.CreatePipeline(Cinemachine.CinemachineVirtualCamera)">
            <summary>Create a default pipeline container.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.InvalidateComponentPipeline">
            <summary>
            Editor API: Call this when changing the pipeline from the editor.
            Will force a rebuild of the pipeline cache.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetComponentOwner">
            <summary>Get the hidden CinemachinePipeline child object.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetComponentPipeline">
            <summary>Get the component pipeline owned by the hidden child pipline container.
            For most purposes, it is preferable to use the GetCinemachineComponent method.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent(Cinemachine.CinemachineCore.Stage)">
            <summary>Get the component set for a specific stage.</summary>
            <param name="stage">The stage for which we want the component</param>
            <returns>The Cinemachine component for that stage, or null if not defined</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent``1">
            <summary>Get an existing component of a specific type from the cinemachine pipeline.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.AddCinemachineComponent``1">
            <summary>Add a component to the cinemachine pipeline.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.DestroyCinemachineComponent``1">
            <summary>Remove a component from the cinemachine pipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.UserIsDragging">
            <summary>API for the editor, to make the dragging of position handles behave better.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBasicMultiChannelPerlin">
            <summary>
            As a part of the Cinemachine Pipeline implementing the Noise stage, this
            component adds Perlin Noise to the Camera state, in the Correction
            channel of the CameraState.
            
            The noise is created by using a predefined noise profile asset.  This defines the 
            shape of the noise over time.  You can scale this in amplitude or in time, to produce
            a large family of different noises using the same profile.
            </summary>
            <seealso cref="T:Cinemachine.NoiseSettings"/>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_NoiseProfile">
            <summary>
            Serialized property for referencing a NoiseSettings asset
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_AmplitudeGain">
            <summary>
            Gain to apply to the amplitudes defined in the settings asset.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_FrequencyGain">
            <summary>
            Scale factor to apply to the frequencies defined in the settings asset.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBasicMultiChannelPerlin.IsValid">
            <summary>True if the component is valid, i.e. it has a noise definition and is enabled.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBasicMultiChannelPerlin.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Noise stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBasicMultiChannelPerlin.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies noise to the Correction channel of the CameraState if the
            delta time is greater than 0.  Otherwise, does nothing.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">How much to advance the perlin noise generator.
            Noise is only applied if this value is greater than or equal to 0</param>
        </member>
        <member name="T:Cinemachine.CinemachineComposer">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera at the vcam's LookAt target object, with 
            configurable offsets, damping, and composition rules.
            
            The composer does not change the camera's position.  It will only pan and tilt the 
            camera where it is, in order to get the desired framing.  To move the camera, you have
            to use the virtual camera's Body section.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.OnGUICallback">
            <summary>Used by the Inspector Editor to display on-screen guides.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_TrackedObjectOffset">
            <summary>Target offset from the object's center in LOCAL space which
            the Composer tracks. Use this to fine-tune the tracking target position
            when the desired area is not in the tracked object's center</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_LookaheadTime">
            <summary>This setting will instruct the composer to adjust its target offset based
            on the motion of the target.  The composer will look at a point where it estimates
            the target will be this many seconds into the future.  Note that this setting is sensitive
            to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
            If the camera jitters unacceptably when the target is in motion, turn down this setting, 
            or animate the target more smoothly.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_LookaheadSmoothing">
            <summary>Controls the smoothness of the lookahead algorithm.  Larger values smooth out 
            jittery predictions and also increase prediction lag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_HorizontalDamping">
            <summary>How aggressively the camera tries to follow the target in the screen-horizontal direction.
            Small numbers are more responsive, rapidly orienting the camera to keep the target in
            the dead zone. Larger numbers give a more heavy slowly responding camera.
            Using different vertical and horizontal settings can yield a wide range of camera behaviors.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_VerticalDamping">
            <summary>How aggressively the camera tries to follow the target in the screen-vertical direction. 
            Small numbers are more responsive, rapidly orienting the camera to keep the target in 
            the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical 
            and horizontal settings can yield a wide range of camera behaviors.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_ScreenX">
            <summary>Horizontal screen position for target. The camera will rotate to the position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_ScreenY">
            <summary>Vertical screen position for target, The camera will rotate to to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_DeadZoneWidth">
            <summary>Camera will not rotate horizontally if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_DeadZoneHeight">
            <summary>Camera will not rotate vertically if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_SoftZoneWidth">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_SoftZoneHeight">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_BiasX">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_BiasY">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.TrackedPoint">
            <summary>Internal API for inspector</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.GetLookAtPointAndSetTrackedPoint(UnityEngine.Vector3)">
            <summary>Apply the target offsets to the target location.
            Also set the TrackedPoint property, taking lookahead into account.</summary>
            <param name="lookAt">The unoffset LookAt point</param>
            <returns>The LookAt point with the offset applied</returns>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_CameraPosPrevFrame">
            <summary>State information for damping</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.SoftGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.HardGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.RotateToScreenBounds(Cinemachine.CameraState@,UnityEngine.Rect,UnityEngine.Quaternion@,System.Single,System.Single,System.Single)">
            <summary>
            Adjust the rigOrientation to put the camera within the screen bounds.
            If deltaTime >= 0 then damping will be applied.
            Assumes that currentOrientation fwd is such that input rigOrientation's
            local up is NEVER NEVER NEVER pointing downwards, relative to
            state.ReferenceUp.  If this condition is violated
            then you will see crazy spinning.  That's the symptom.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.ClampVerticalBounds(UnityEngine.Rect@,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Prevent upside-down camera situation.  This can happen if we have a high
            camera pitch combined with composer settings that cause the camera to tilt
            beyond the vertical in order to produce the desired framing.  We prevent this by
            clamping the composer's vertical settings so that this situation can't happen.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer">
            <summary>
            This is a Cinemachine Component in the Body section of the component pipeline. 
            Its job is to position the camera in a fixed screen-space relationship to 
            the vcam's Follow target object, with offsets and damping.
            
            The camera will be first moved along the camera Z axis until the Follow target
            is at the desired distance from the camera's X-Y plane.  The camera will then
            be moved in its XY plane until the Follow target is at the desired point on
            the camera's screen.
            
            The FramingTansposer will only change the camera's position in space.  It will not 
            re-orient or otherwise aim the camera.
            
            For this component to work properly, the vcam's LookAt target must be null.
            The Follow target will define what the camera is looking at.
            
            If the Follow target is a CinemachineTargetGroup, then additional controls will 
            be available to dynamically adjust the camera’s view in order to frame the entire group.
            
            Although this component was designed for orthographic cameras, it works equally  
            well with persective cameras and can be used in 3D environments.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.OnGUICallback">
            <summary>Used by the Inspector Editor to display on-screen guides.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_LookaheadTime">
            <summary>This setting will instruct the composer to adjust its target offset based
            on the motion of the target.  The composer will look at a point where it estimates
            the target will be this many seconds into the future.  Note that this setting is sensitive
            to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
            If the camera jitters unacceptably when the target is in motion, turn down this setting, 
            or animate the target more smoothly.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_LookaheadSmoothing">
            <summary>Controls the smoothness of the lookahead algorithm.  Larger values smooth out 
            jittery predictions and also increase prediction lag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset in the X-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Y-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Z-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ScreenX">
            <summary>Horizontal screen position for target. The camera will move to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ScreenY">
            <summary>Vertical screen position for target, The camera will move to to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_CameraDistance">
            <summary>The distance along the camera axis that will be maintained from the Follow target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneWidth">
            <summary>Camera will not move horizontally if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneHeight">
            <summary>Camera will not move vertically if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneDepth">
            <summary>The camera will not move along its z-axis if the Follow target is within this distance of the specified camera distance</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_SoftZoneWidth">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_SoftZoneHeight">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_BiasX">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_BiasY">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer.FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.Horizontal">
            <summary>Consider only the horizontal dimension.  Vertical framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.Vertical">
            <summary>Consider only the vertical dimension.  Horizontal framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.HorizontalAndVertical">
            <summary>The larger of the horizontal and vertical dimensions will dominate, to get the best fit.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.None">
            <summary>Don't do any framing adjustment</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_GroupFramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer.AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.ZoomOnly">
            <summary>Do not move the camera, only adjust the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyOnly">
            <summary>Just move the camera, don't change the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyThenZoom">
            <summary>Move the camera as much as permitted by the ranges, then
            adjust the FOV if necessary to make the shot.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_GroupFramingSize">
            <summary>How much of the screen to fill with the bounding box of the targets.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaxDollyIn">
            <summary>How much closer to the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaxDollyOut">
            <summary>How much farther from the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumDistance">
            <summary>Set this to limit how close to the target the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumDistance">
            <summary>Set this to limit how far from the taregt the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumFOV">
            <summary>If adjusting FOV, will not set the FOV lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumFOV">
            <summary>If adjusting FOV, will not set the FOV higher than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it higher than this</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.SoftGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.HardGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.IsValid">
            <summary>True if component is enabled and has a valid Follow target</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_PreviousCameraPosition">
            <summary>State information for damping</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.TrackedPoint">
            <summary>Internal API for inspector</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFramingTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.m_LastBounds">
            <summary>For editor visulaization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.m_lastBoundsMatrix">
            <summary>For editor visualization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.TargetGroup">
            <summary>Get Follow target as CinemachineTargetGroup, or null if target is not a group</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera at a target object, with configurable offsets, damping, 
            and composition rules.
            
            In addition, if the target is a CinemachineTargetGroup, the behaviour
            will adjust the FOV and the camera distance to ensure that the entire group of targets
            is framed properly.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_GroupFramingSize">
            <summary>How much of the screen to fill with the bounding box of the targets.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer.FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.Horizontal">
            <summary>Consider only the horizontal dimension.  Vertical framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.Vertical">
            <summary>Consider only the vertical dimension.  Horizontal framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.HorizontalAndVertical">
            <summary>The larger of the horizontal and vertical dimensions will dominate, to get the best fit.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_FrameDamping">
            <summary>How aggressively the camera tries to frame the group.
            Small numbers are more responsive</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer.AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.ZoomOnly">
            <summary>Do not move the camera, only adjust the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyOnly">
            <summary>Just move the camera, don't change the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyThenZoom">
            <summary>Move the camera as much as permitted by the ranges, then
            adjust the FOV if necessary to make the shot.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaxDollyIn">
            <summary>How much closer to the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaxDollyOut">
            <summary>How much farther from the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumDistance">
            <summary>Set this to limit how close to the target the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumDistance">
            <summary>Set this to limit how far from the taregt the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumFOV">
            <summary>If adjusting FOV, will not set the FOV lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumFOV">
            <summary>If adjusting FOV, will not set the FOV higher than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it higher than this</summary>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.TargetGroup">
            <summary>Get LookAt target as CinemachineTargetGroup, or null if target is not a group</summary>
        </member>
        <member name="M:Cinemachine.CinemachineGroupComposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="state">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.m_LastBounds">
            <summary>For editor visulaization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.m_lastBoundsMatrix">
            <summary>For editor visualization of the calculated bounding box of the group</summary>
        </member>
        <member name="T:Cinemachine.CinemachineHardLockToTarget">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to place the camera on the Follow Target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLockToTarget.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLockToTarget.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineHardLockToTarget.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineHardLookAt">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera hard at the LookAt target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLookAt.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLookAt.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineHardLookAt.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer">
            <summary>
            This is a CinemachineComponent in the the Body section of the component pipeline. 
            Its job is to position the camera in a variable relationship to a the vcam's 
            Follow target object, with offsets and damping.
            
            This component is typically used to implement a camera that follows its target.
            It can accept player input from an input device, which allows the player to 
            dynamically control the relationship between the camera and the target, 
            for example with a joystick.
            
            The OrbitalTransposer introduces the concept of __Heading__, which is the direction
            in which the target is moving, and the OrbitalTransposer will attempt to position 
            the camera in relationship to the heading, which is by default directly behind the target.
            You can control the default relationship by adjusting the Heading Bias setting.
            
            If you attach an input controller to the OrbitalTransposer, then the player can also
            control the way the camera positions itself in relation to the target heading.  This allows
            the camera to move to any spot on an orbit around the target.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Heading">
            <summary>
            How the "forward" direction is defined.  Orbital offset is in relation to the forward
            direction.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition">
            <summary>
            Sets the algorithm for determining the target's heading for purposes
            of re-centering the camera
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.PositionDelta">
            <summary>
            Target heading calculated from the difference between its position on
            the last update and current frame.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.Velocity">
            <summary>
            Target heading calculated from its <b>Rigidbody</b>'s velocity.
            If no <b>Rigidbody</b> exists, it will fall back
            to HeadingDerivationMode.PositionDelta
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward">
            <summary>
            Target heading calculated from the Target <b>Transform</b>'s euler Y angle
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.WorldForward">
            <summary>
            Default heading is a constant world space heading.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_HeadingDefinition">
            <summary>The method by which the 'default heading' is calculated if
            recentering to target heading is enabled</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_VelocityFilterStrength">
            <summary>Size of the velocity sampling window for target heading filter.
            Used only if deriving heading from target's movement</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_HeadingBias">
            <summary>Additional Y rotation applied to the target heading.
            When this value is 0, the camera will be placed behind the target</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Heading.#ctor(Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition,System.Int32,System.Single)">
            <summary>Constructor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_Heading">
            <summary>The definition of Forward.  Camera will follow behind.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Recentering">
            <summary>Controls how automatic orbit recentering occurs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_enabled">
            <summary>If checked, will enable automatic recentering of the
            camera based on the heading calculation mode. If FALSE, recenting is disabled.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_RecenterWaitTime">
            <summary>If no input has been detected, the camera will wait
            this long in seconds before moving its heading to the default heading.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_RecenteringTime">
            <summary>Maximum angular speed of recentering.  Will accelerate into and decelerate out of this</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Recentering.#ctor(System.Boolean,System.Single,System.Single)">
            <summary>Constructor with specific field values</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Recentering.Validate">
            <summary>Call this from OnValidate()</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_RecenterToTargetHeading">
            <summary>Parameters that control Automating Heading Recentering</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_XAxis">
            <summary>Axis representing the current heading.  Value is in degrees
            and represents a rotation about the up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_HeadingIsSlave">
            <summary>
            Drive the x-axis setting programmatically.
            Automatic heading updating will be disabled.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.UpdateHeadingDelegate">
            <summary>
            Delegate that allows the the m_XAxis object to be replaced with another one.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.HeadingUpdater">
            <summary>
            Delegate that allows the the XAxis object to be replaced with another one.
            To use it, just call orbital.UpdateHeading() with a reference to a 
            private AxisState object, and that AxisState object will be updated and
            used to calculate the heading.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.UpdateHeading(System.Single,UnityEngine.Vector3,Cinemachine.AxisState@)">
            <summary>
            Update the X axis and calculate the heading.  This can be called by a delegate
            with a custom axis.
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
            <param name="up">World Up, set by the CinemachineBrain</param>
            <param name="axis"></param>
            <returns>Axis value</returns>
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset, after zeroing out local x.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachinePOV">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera in response to the user's mouse or joystick input.
            
            The composer does not change the camera's position.  It will only pan and tilt the 
            camera where it is, in order to get the desired framing.  To move the camera, you have
            to use the virtual camera's Body section.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachinePOV.m_VerticalAxis">
            <summary>The Vertical axis.  Value is -90..90. Controls the vertical orientation</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePOV.m_HorizontalAxis">
            <summary>The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePOV.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePOV.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePOV.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the axis values and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  Not used.</param>
        </member>
        <member name="T:Cinemachine.CinemachineSameAsFollowObject">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera hard at the LookAt target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineSameAsFollowObject.IsValid">
            <summary>True if component is enabled and has a Follow target defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSameAsFollowObject.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSameAsFollowObject.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly">
            <summary>
            A Cinemachine Virtual Camera Body component that constrains camera motion
            to a CinemachinePath.  The camera can move along the path.
            
            This behaviour can operate in two modes: manual positioning, and Auto-Dolly positioning.  
            In Manual mode, the camera's position is specified by animating the Path Position field.  
            In Auto-Dolly mode, the Path Position field is animated automatically every frame by finding
            the position on the path that's closest to the virtual camera's Follow target.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_Path">
            <summary>The path to which the camera will be constrained.  This must be non-null.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PathPosition">
            <summary>The position along the path at which the camera will be placed.
            This can be animated directly, or set automatically by the Auto-Dolly feature
            to get as close as possible to the Follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PathOffset">
            <summary>Where to put the camera realtive to the path postion.  X is perpendicular to the path, Y is up, and Z is parallel to the path.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset perpendicular to the path.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the path-local up direction.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset parallel to the path.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly.CameraUpMode">
            <summary>Different ways to set the camera's up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default">
            <summary>Leave the camera's up vector alone.  It will be set according to the Brain's WorldUp.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.Path">
            <summary>Take the up vector from the path's up vector at the current point</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.PathNoRoll">
            <summary>Take the up vector from the path's up vector at the current point, but with the roll zeroed out</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTarget">
            <summary>Take the up vector from the Follow target's up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTargetNoRoll">
            <summary>Take the up vector from the Follow target's up vector, but with the roll zeroed out</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_CameraUp">
            <summary>How to set the virtual camera's Up vector.  This will affect the screen composition.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PitchDamping">
            <summary>"How aggressively the camera tries to track the target rotation's X angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_YawDamping">
            <summary>How aggressively the camera tries to track the target rotation's Y angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_RollDamping">
            <summary>How aggressively the camera tries to track the target rotation's Z angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly.AutoDolly">
            <summary>Controls how automatic dollying occurs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_Enabled">
            <summary>If checked, will enable automatic dolly, which chooses a path position
            that is as close as possible to the Follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_PositionOffset">
            <summary>Offset, in current position units, from the closest point on the path to the follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_SearchRadius">
            <summary>Search up to how many waypoints on either side of the current position.  Use 0 for Entire path</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_SearchResolution">
            <summary>We search between waypoints by dividing the segment into this many straight pieces.
            The higher the number, the more accurate the result, but performance is
            proportionally slower for higher numbers</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.AutoDolly.#ctor(System.Boolean,System.Single,System.Int32,System.Int32)">
            <summary>Constructor with specific field values</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_AutoDolly">
            <summary>Controls how automatic dollying occurs</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTrackedDolly.IsValid">
            <summary>True if component is enabled and has a path</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTrackedDolly.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less that 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachineTransposer">
            <summary>
            This is a CinemachineComponent in the Body section of the component pipeline. 
            Its job is to position the camera in a fixed relationship to the vcam's Follow 
            target object, with offsets and damping.
            
            The Tansposer will only change the camera's position in space.  It will not 
            re-orient or otherwise aim the camera.  To to that, you need to instruct 
            the vcam in the Aim section of its pipeline.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineTransposer.BindingMode">
            <summary>
            The coordinate space to use when interpreting the offset from the target
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetOnAssign">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame at the moment when the virtual camera was enabled,
            or when the target was assigned.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetWithWorldUp">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame, with the tilt and roll zeroed out.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetNoRoll">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame, with the roll zeroed out.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTarget">
            <summary>
            Camera will be bound to the Follow target using the target's local frame.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.WorldSpace">
            <summary>Camera will be bound to the Follow target using a world space offset.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp">
            <summary>Offsets will be calculated relative to the target, using Camera-local axes</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_BindingMode">
            <summary>The coordinate space to use when interpreting the offset from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_FollowOffset">
            <summary>The distance which the transposer will attempt to maintain from the transposer subject</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset in the X-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Y-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Z-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_PitchDamping">
            <summary>How aggressively the camera tries to track the target rotation's X angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_YawDamping">
            <summary>How aggressively the camera tries to track the target rotation's Y angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_RollDamping">
            <summary>How aggressively the camera tries to track the target rotation's Z angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.EffectiveOffset">
            <summary>Get the target offset, with sanitization</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.IsValid">
            <summary>True if component is enabled and has a valid Follow target</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.InitPrevFrameStateInfo(Cinemachine.CameraState@,System.Single)">
            <summary>Initializes the state for previous frame if appropriate.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.TrackTarget(System.Single,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
            <param name="up">Current camera up</param>
            <param name="desiredCameraOffset">Where we want to put the camera relative to the follow target</param>
            <param name="outTargetPosition">Resulting camera position</param>
            <param name="outTargetOrient">Damped target orientation</param>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.Damping">
            <summary>
            Damping speeds for each of the 3 axes of the offset from target
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.AngularDamping">
            <summary>
            Damping speeds for each of the 3 axes of the target's rotation
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.GeTargetCameraPosition(UnityEngine.Vector3)">
            <summary>Internal API for the Inspector Editor, so it can draw a marker at the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_PreviousTargetPosition">
            <summary>State information for damping</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.GetReferenceOrientation(UnityEngine.Vector3)">
            <summary>Internal API for the Inspector Editor, so it can draw a marker at the target</summary>
        </member>
        <member name="T:Cinemachine.AxisState">
            <summary>
            Axis state for defining to react to player input.  
            The settings here control the responsiveness of the axis to player input.
            </summary>
        </member>
        <member name="F:Cinemachine.AxisState.Value">
            <summary>The current value of the axis</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_MaxSpeed">
            <summary>How fast the axis value can travel.  Increasing this number
            makes the behaviour more responsive to joystick input</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_AccelTime">
            <summary>The amount of time in seconds it takes to accelerate to
            MaxSpeed with the supplied Axis at its maximum value</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_DecelTime">
            <summary>The amount of time in seconds it takes to decelerate
            the axis to zero if the supplied axis is in a neutral position</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InputAxisName">
            <summary>The name of this axis as specified in Unity Input manager.
            Setting to an empty string will disable the automatic updating of this axis</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InputAxisValue">
            <summary>The value of the input axis.  A value of 0 means no input
            You can drive this directly from a
            custom input system, or you can set the Axis Name and have the value
            driven by the internal Input Manager</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InvertAxis">
            <summary>If checked, then the raw value of the input axis will be inverted 
            before it is used.</summary>
        </member>
        <member name="M:Cinemachine.AxisState.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.Boolean)">
            <summary>Constructor with specific values</summary>
        </member>
        <member name="M:Cinemachine.AxisState.Validate">
            <summary>Call from OnValidate: Make sure the fields are sensible</summary>
        </member>
        <member name="M:Cinemachine.AxisState.SetThresholds(System.Single,System.Single,System.Boolean)">
            <summary>
            Sets the constraints by which this axis will operate on
            </summary>
            <param name="minValue">The lowest value this axis can achieve</param>
            <param name="maxValue">The highest value this axis can achieve</param>
            <param name="wrapAround">If <b>true</b>, values commanded greater
            than mMaxValue or less than mMinValue will wrap around.
            If <b>false</b>, the value will be clamped within the range.</param>
        </member>
        <member name="M:Cinemachine.AxisState.Update(System.Single)">
            <summary>
            Updates the state of this axis based on the axis defined
            by AxisState.m_AxisName
            </summary>
            <param name="deltaTime">Delta time in seconds</param>
            <returns>Returns <b>true</b> if this axis' input was non-zero this Update,
            <b>flase</b> otherwise</returns>
        </member>
        <member name="T:Cinemachine.CameraState">
            <summary>
            The output of the Cinemachine engine for a specific virtual camera.  The information
            in this struct can be blended, and provides what is needed to calculate an
            appropriate camera position, orientation, and lens setting.
            
            Raw values are what the Cinemachine behaviours generate.  The correction channel
            holds perturbations to the raw values - e.g. noise or smoothing, or obstacle
            avoidance corrections.  Coirrections are not considered when making time-based
            calculations such as damping.
            
            The Final position and orientation is the comination of the raw values and
            their corrections.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.Lens">
            <summary>
            Camera Lens Settings.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.ReferenceUp">
            <summary>
            Which way is up.  World space unit vector.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.ReferenceLookAt">
            <summary>
            The world space focus point of the camera.  What the camera wants to look at.
            There is a special constant define to represent "nothing".  Be careful to 
            check for that (or check the HasLookAt property).
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.HasLookAt">
            <summary>
            Returns true if this state has a valid ReferenceLookAt value.
            </summary>
        </member>
        <member name="F:Cinemachine.CameraState.kNoPoint">
            <summary>
            This constant represents "no point in space" or "no direction".
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.RawPosition">
            <summary>
            Raw (un-corrected) world space position of this camera
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.RawOrientation">
            <summary>
            Raw (un-corrected) world space orientation of this camera
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.PositionDampingBypass">
            <summary>This is a way for the Body component to bypass aim damping,
            useful for when the body need to rotate its point of view, but does not
            want interference from the aim damping</summary>
        </member>
        <member name="P:Cinemachine.CameraState.ShotQuality">
            <summary>
            Subjective estimation of how "good" the shot is.
            Larger values mean better quality.  Default is 1.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.PositionCorrection">
            <summary>
            Position correction.  This will be added to the raw position.
            This value doesn't get fed back into the system when calculating the next frame.
            Can be noise, or smoothing, or both, or something else.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.OrientationCorrection">
            <summary>
            Orientation correction.  This will be added to the raw orientation.
            This value doesn't get fed back into the system when calculating the next frame.
            Can be noise, or smoothing, or both, or something else.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.CorrectedPosition">
            <summary>
            Position with correction applied.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.CorrectedOrientation">
            <summary>
            Orientation with correction applied.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.FinalPosition">
            <summary>
            Position with correction applied.  This is what the final camera gets.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.FinalOrientation">
            <summary>
            Orientation with correction and dutch applied.  This is what the final camera gets.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.Default">
            <summary>
            State with default values
            </summary>
        </member>
        <member name="T:Cinemachine.CameraState.CustomBlendable">
            <summary>Opaque structure represent extra blendable stuff and its weight.
            The base system ignores this data - it is intended for extension modules</summary>
        </member>
        <member name="F:Cinemachine.CameraState.CustomBlendable.m_Custom">
            <summary>The custom stuff that the extention module will consider</summary>
        </member>
        <member name="F:Cinemachine.CameraState.CustomBlendable.m_Weight">
            <summary>The weight of the custom stuff.  Must be 0...1</summary>
        </member>
        <member name="M:Cinemachine.CameraState.CustomBlendable.#ctor(UnityEngine.Object,System.Single)">
            <summary>Constructor with specific values</summary>
            <param name="custom">The custom stuff that the extention module will consider</param>
            <param name="weight">The weight of the custom stuff.  Must be 0...1</param>
        </member>
        <member name="P:Cinemachine.CameraState.NumCustomBlendables">
            <summary>The number of custom blendables that will be applied to the camera.  
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
        </member>
        <member name="M:Cinemachine.CameraState.GetCustomBlendable(System.Int32)">
            <summary>Get a custom blendable that will be applied to the camera.  
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
            <param name="index">Which one to get.  Must be in range [0...NumCustomBlendables)</param>
            <returns>The custom blendable at the specified index.</returns>
        </member>
        <member name="M:Cinemachine.CameraState.AddCustomBlendable(Cinemachine.CameraState.CustomBlendable)">
            <summary>Add a custom blendable to the pot for eventual application to the camera.
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
            <param name="b">The custom blendable to add.  If b.m_Custom is the same as an 
            already-added custom blendable, then they will be merged and the weights combined.</param>
        </member>
        <member name="M:Cinemachine.CameraState.Lerp(Cinemachine.CameraState,Cinemachine.CameraState,System.Single)">
            <summary>Intelligently blend the contents of two states.</summary>
            <param name="stateA">The first state, corresponding to t=0</param>
            <param name="stateB">The second state, corresponding to t=1</param>
            <param name="t">How much to interpolate.  Internally clamped to 0..1</param>
            <returns>Linearly interpolated CameraState</returns>
        </member>
        <member name="T:Cinemachine.CinemachineBlend">
            <summary>
            Describes a blend between 2 Cinemachine Virtual Cameras, and holds the
            current state of the blend.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.CamA">
            <summary>First camera in the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.CamB">
            <summary>Second camera in the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.BlendCurve">
            <summary>The curve that describes the way the blend transitions over time
            from the first camera to the second.  X-axis is time in seconds over which
            the blend takes place and Y axis is blend weight (0..1)</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.TimeInBlend">
            <summary>The current time relative to the start of the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.BlendWeight">
            <summary>The current weight of the blend.  This is an evaluation of the
            BlendCurve at the current time relative to the start of the blend.
            0 means camA, 1 means camB.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.IsValid">
            <summary>Validity test for the blend.  True if both cameras are defined.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.Duration">
            <summary>Duration in seconds of the blend.
            This is given read from the BlendCurve.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.IsComplete">
            <summary>True if the time relative to the start of the blend is greater
            than or equal to the blend duration</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.Description">
            <summary>Text description of the blend, for debugging</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.Uses(Cinemachine.ICinemachineCamera)">
            <summary>Does the blend use a specific Cinemachine Virtual Camera?</summary>
            <param name="cam">The camera to test</param>
            <returns>True if the camera is involved in the blend</returns>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.#ctor(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,UnityEngine.AnimationCurve,System.Single,System.Single)">
            <summary>Construct a blend</summary>
            <param name="a">First camera</param>
            <param name="b">Second camera</param>
            <param name="curve">Blend curve</param>
            <param name="t">Current time in blend, relative to the start of the blend</param>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Make sure the source cameras get updated.</summary>
            <param name="worldUp">Default world up.  Individual vcams may modify this</param>
            <param name="deltaTime">Time increment used for calculating time-based behaviours (e.g. damping)</param>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.State">
            <summary>Compute the blended CameraState for the current time in the blend.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinition">
            <summary>Definition of a Camera blend.  This struct holds the information
            necessary to generate a suitable AnimationCurve for a Cinemachine Blend.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinition.Style">
            <summary>Supported predefined shapes for the blend curve.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.Cut">
            <summary>Zero-length blend</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseInOut">
            <summary>S-shaped curve, giving a gentle and smooth transition</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseIn">
            <summary>Linear out of the outgoing shot, and easy into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseOut">
            <summary>Easy out of the outgoing shot, and linear into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.HardIn">
            <summary>Easy out of the outgoing, and hard into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.HardOut">
            <summary>Hard out of the outgoing, and easy into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.Linear">
            <summary>Linear blend.  Mechanical-looking.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.m_Style">
            <summary>The shape of the blend curve.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.m_Time">
            <summary>The duration (in seconds) of the blend</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendDefinition.#ctor(Cinemachine.CinemachineBlendDefinition.Style,System.Single)">
            <summary>Constructor</summary>
            <param name="style">The shape of the blend curve.</param>
            <param name="time">The duration (in seconds) of the blend</param>
        </member>
        <member name="P:Cinemachine.CinemachineBlendDefinition.BlendCurve">
            <summary>
            An AnimationCurve specifying the interpolation duration and value
            for this camera blend. The time of the last key frame is assumed to the be the
            duration of the blend. Y-axis values must be in range [0,1] (internally clamped
            within Blender) and time must be in range of [0, +infinity)
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlenderSettings">
            <summary>
            Asset that defines the rules for blending between Virtual Cameras.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlenderSettings.CustomBlend">
            <summary>
            Container specifying how two specific Cinemachine Virtual Cameras
            blend together.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlenderSettings.m_CustomBlends">
            <summary>The array containing explicitly defined blends between two Virtual Cameras</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlenderSettings.kBlendFromAnyCameraLabel">
            <summary>Internal API for the inspector editopr: a label to represent any camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlenderSettings.GetBlendCurveForVirtualCameras(System.String,System.String,UnityEngine.AnimationCurve)">
            <summary>
            Attempts to find a blend curve which matches the to and from cameras as specified.
            If no match is found, the function returns either the
            default blend for this Blender or NULL depending on the state
            of <b>returnDefaultOnNoMatch</b>.
            </summary>
            <param name="fromCameraName">The game object name of the from camera</param>
            <param name="toCameraName">The game object name of the to camera</param>
            <param name="defaultCurve">Curve to return if no curve found.  Can be NULL.</param>
            <returns></returns>
        </member>
        <member name="T:Cinemachine.CinemachineComponentBase">
            <summary>
            An abstract representation of a mutator acting on a Cinemachine Virtual Camera
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineComponentBase.Epsilon">
            <summary>Useful constant for very small floats</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.VirtualCamera">
            <summary>Get the associated CinemachineVirtualCameraBase</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.FollowTarget">
            <summary>Returns the owner vcam's Follow target.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.LookAtTarget">
            <summary>Returns the owner vcam's LookAt target.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.VcamState">
            <summary>Returns the owner vcam's CameraState.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.IsValid">
            <summary>Returns true if this object is enabled and set up to produce results.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.PrePipelineMutateCameraState(Cinemachine.CameraState@)">
            <summary>Override this to do such things as offset the RefereceLookAt.
            Base class implementation does nothing.</summary>
            <param name="curState">Input state that must be mutated</param>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.Stage">
            <summary>What part of the pipeline this fits into</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Mutates the camera state.  This state will later be applied to the camera.</summary>
            <param name="curState">Input state that must be mutated</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            Base class implementation does nothing.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachineCore">
            <summary>A singleton that manages complete lists of CinemachineBrain and,
            Cinemachine Virtual Cameras, and the priority queue.  Provides
            services to keeping track of whether Cinemachine Virtual Cameras have
            been updated each frame.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.kStreamingVersion">
            <summary>Data version string.  Used to upgrade from legacy projects</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.kVersionString">
            <summary>Human-readable Cinemachine Version</summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.Stage">
            <summary>
            Stages in the Cinemachine Component pipeline, used for
            UI organization>.  This enum defines the pipeline order.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Body">
            <summary>Second stage: position the camera in space</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Aim">
            <summary>Third stage: orient the camera to point at the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Noise">
            <summary>Final stage: apply noise (this is done separately, in the
            Correction channel of the CameraState)</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.Instance">
            <summary>Get the singleton instance</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.sShowHiddenObjects">
            <summary>
            If true, show hidden Cinemachine objects, to make manual script mapping possible.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.AxisInputDelegate">
            <summary>Delegate for overriding Unity's default input system.  Returns the value
            of the named axis.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.GetInputAxis">
            <summary>Delegate for overriding Unity's default input system.
            If you set this, then your delegate will be called instead of
            System.Input.GetAxis(axisName) whenever in-game user input is needed.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.mActiveBrains">
            <summary>List of all active CinemachineBrains.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.BrainCount">
            <summary>Access the array of active CinemachineBrains in the scene</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetActiveBrain(System.Int32)">
            <summary>Access the array of active CinemachineBrains in the scene 
            without gebnerating garbage</summary>
            <param name="index">Index of the brain to access, range 0-BrainCount</param>
            <returns>The brain at the specified index</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddActiveBrain(Cinemachine.CinemachineBrain)">
            <summary>Called when a CinemachineBrain is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveActiveBrain(Cinemachine.CinemachineBrain)">
            <summary>Called when a CinemachineBrain is disabled.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.mActiveCameras">
            <summary>List of all active ICinemachineCameras.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.VirtualCameraCount">
            <summary>
            List of all active Cinemachine Virtual Cameras for all brains.
            This list is kept sorted by priority.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetVirtualCamera(System.Int32)">
            <summary>Access the array of active ICinemachineCamera in the scene 
            without gebnerating garbage</summary>
            <param name="index">Index of the camera to access, range 0-VirtualCameraCount</param>
            <returns>The virtual camera at the specified index</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddActiveCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a Cinemachine Virtual Camera is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveActiveCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a Cinemachine Virtual Camera is disabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddChildCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a child vcam is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveChildCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a child vcam is disabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.UpdateAllActiveVirtualCameras(UnityEngine.Vector3,System.Single)">
            <summary>Update all the active vcams in the scene, in the correct dependency order.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.UpdateVirtualCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>
            Update a single Cinemachine Virtual Camera if and only if it
            hasn't already been updated this frame.  Always update vcams via this method.
            Calling this more than once per frame for the same camera will have no effect.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.UpdateFilter">
            <summary>Internal use only</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetVcamUpdateStatus(Cinemachine.ICinemachineCamera)">
            <summary>Internal use only</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.IsLive(Cinemachine.ICinemachineCamera)">
            <summary>
            Is this virtual camera currently actively controlling any Camera?
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GenerateCameraActivationEvent(Cinemachine.ICinemachineCamera)">
            <summary>
            Signal that the virtual has been activated.
            If the camera is live, then all CinemachineBrains that are showing it will
            send an activation event.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GenerateCameraCutEvent(Cinemachine.ICinemachineCamera)">
            <summary>
            Signal that the virtual camera's content is discontinuous WRT the previous frame.
            If the camera is live, then all CinemachineBrains that are showing it will send a cut event.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.FindPotentialTargetBrain(Cinemachine.ICinemachineCamera)">
            <summary>
            Try to find a CinemachineBrain to associate with a
            Cinemachine Virtual Camera.  The first CinemachineBrain
            in which this Cinemachine Virtual Camera is live will be used.
            If none, then the first active CinemachineBrain will be used.
            Brains with OutputCamera == null will not be returned.
            Final result may be null.
            </summary>
            <param name="vcam">Virtual camera whose potential brain we need.</param>
            <returns>First CinemachineBrain found that might be
            appropriate for this vcam, or null</returns>
        </member>
        <member name="T:Cinemachine.Utility.CinemachineGameWindowDebug">
            <summary>Manages onscreen positions for Cinemachine debugging output</summary>
        </member>
        <member name="M:Cinemachine.Utility.CinemachineGameWindowDebug.ReleaseScreenPos(UnityEngine.Object)">
            <summary>Release a screen rectangle previously obtained through GetScreenPos()</summary>
            <param name="client">The client caller.  Used as a handle.</param>
        </member>
        <member name="M:Cinemachine.Utility.CinemachineGameWindowDebug.GetScreenPos(UnityEngine.Object,System.String,UnityEngine.GUIStyle)">
            <summary>Reserve an on-screen rectangle for debugging output.</summary>
            <param name="client">The client caller.  This is used as a handle.</param>
            <param name="text">Sample text, for determining rectangle size</param>
            <param name="style">What style will be used to draw, used here for
            determining rect size</param>
            <returns>An area on the game screen large enough to print the text
            in the style indicated</returns>
        </member>
        <member name="M:Cinemachine.Utility.GaussianWindow1d`1.Value">
            Returned value will be kernelRadius old
        </member>
        <member name="T:Cinemachine.Utility.Damper">
            <summary>Utility to perform realistic damping of float or Vector3 values.
            The algorithm is based on exponentially decaying the delta until only
            a negligible amount remains.</summary>
        </member>
        <member name="F:Cinemachine.Utility.Damper.kNegligibleResidual">
            <summary>Standard residual</summary>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(System.Single,System.Single,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="T:Cinemachine.Utility.ReflectionHelpers">
            <summary>An ad-hoc collection of helpers for reflection, used by Cinemachine
            or its editor tools in various places</summary>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.CopyFields(System.Object,System.Object,System.Reflection.BindingFlags)">
            <summary>Copy the fields from one object to another</summary>
            <param name="src">The source object to copy from</param>
            <param name="dst">The destination object to copy to</param>
            <param name="bindingAttr">The mask to filter the attributes.
            Only those fields that get caught in the filter will be copied</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInAssembly(System.Reflection.Assembly,System.Predicate{System.Type})">
            <summary>Search the assembly for all types that match a predicate</summary>
            <param name="assembly">The assembly to search</param>
            <param name="predicate">The type to look for</param>
            <returns>A list of types found in the assembly that inherit from the predicate</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypeInAllLoadedAssemblies(System.String)">
            <summary>Get a type from a name</summary>
            <param name="typeName">The name of the type to search for</param>
            <returns>The type matching the name, or null if not found</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInAllLoadedAssemblies(System.Predicate{System.Type})">
            <summary>Search all assemblies for all types that match a predicate</summary>
            <param name="predicate">The type to look for</param>
            <returns>A list of types found in the assembly that inherit from the predicate</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInLoadedAssemblies(System.Predicate{System.Reflection.Assembly},System.Predicate{System.Type})">
            <summary>call GetTypesInAssembly() for all assemblies that match a predicate</summary>
            <param name="assemblyPredicate">Which assemblies to search</param>
            <param name="predicate">What type to look for</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.AccessInternalField``1(System.Type,System.Object,System.String)">
            <summary>Cheater extension to access internal field of an object</summary>
            <param name="type">The type of the field</param>
            <param name="obj">The object to access</param>
            <param name="memberName">The string name of the field to access</param>
            <returns>The value of the field in the objects</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetParentObject(System.String,System.Object)">
            <summary>Get the object owner of a field.  This method processes
            the '.' separator to get from the object that owns the compound field
            to the object that owns the leaf field</summary>
            <param name="path">The name of the field, which may contain '.' separators</param>
            <param name="obj">the owner of the compound field</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetFieldPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>Returns a string path from an expression - mostly used to retrieve serialized properties
            without hardcoding the field path. Safer, and allows for proper refactoring.</summary>
        </member>
        <member name="T:Cinemachine.Utility.UnityVectorExtensions">
            <summary>Extensions to the Vector3 class, used by Cinemachine</summary>
        </member>
        <member name="F:Cinemachine.Utility.UnityVectorExtensions.Epsilon">
            <summary>A useful Epsilon</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the closest point on a line segment.
            </summary>
            <param name="p">A point in space</param>
            <param name="s0">Start of line segment</param>
            <param name="s1">End of line segment</param>
            <returns>The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Get the closest point on a line segment.
            </summary>
            <param name="p">A point in space</param>
            <param name="s0">Start of line segment</param>
            <param name="s1">End of line segment</param>
            <returns>The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Returns a non-normalized projection of the supplied vector onto a plane
            as described by its normal
            </summary>
            <param name="vector"></param>
            <param name="planeNormal">The normal that defines the plane.  Cannot be zero-length.</param>
            <returns>The component of the vector that lies in the plane</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.AlmostZero(UnityEngine.Vector3)">
            <summary>Is the vector within Epsilon of zero length?</summary>
            <param name="v"></param>
            <returns>True if the square magnitude of the vector is within Epsilon of zero</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.SignedAngle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>Get a signed angle between two vectors</summary>
            <param name="from">Start direction</param>
            <param name="to">End direction</param>
            <param name="refNormal">This is needed in order to determine the sign.
            For example, if from an to lie on the XZ plane, then this would be the
            Y unit vector, or indeed any vector which, when dotted with Y unit vector,
            would give a positive result.</param>
            <returns>The signed angle between the vectors</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.SlerpWithReferenceUp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
            <summary>This is a slerp that mimics a camera operator's movement in that
            it chooses a path that avoids the lower hemisphere, as defined by
            the up param</summary>
            <param name="vA">First direction</param>
            <param name="vB">Second direction</param>
            <param name="t">Interpolation amoun t</param>
            <param name="up">Defines the up direction</param>
        </member>
        <member name="T:Cinemachine.Utility.UnityQuaternionExtensions">
            <summary>Extentions to the Quaternion class, usen in various places by Cinemachine</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single,UnityEngine.Vector3)">
            <summary>This is a slerp that mimics a camera operator's movement in that
            it chooses a path that avoids the lower hemisphere, as defined by
            the up param</summary>
            <param name="qA">First direction</param>
            <param name="qB">Second direction</param>
            <param name="t">Interpolation amoun t</param>
            <param name="up">Defines the up direction</param>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.Normalized(UnityEngine.Quaternion)">
            <summary>Normalize a quaternion</summary>
            <param name="q"></param>
            <returns>The normalized quaternion.  Unit length is 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(UnityEngine.Quaternion,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the rotations, first about world up, then about (travelling) local right,
            necessary to align the quaternion's forward with the target direction.
            This represents the tripod head movement needed to look at the target.
            This formulation makes it easy to interpolate without introducing spurious roll.
            </summary>
            <param name="orient"></param>
            <param name="lookAtDir">The worldspace target direction in which we want to look</param>
            <param name="worldUp">Which way is up</param>
            <returns>Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
            about local right.</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(UnityEngine.Quaternion,UnityEngine.Vector2,UnityEngine.Vector3)">
            <summary>
            Apply rotations, first about world up, then about (travelling) local right.
            rot.y is rotation about worldUp, and rot.x is second rotation, about local right.
            </summary>
            <param name="orient"></param>
            <param name="rot">Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
            about local right.</param>
            <param name="worldUp">Which way is up</param>
        </member>
        <member name="T:Cinemachine.Utility.UnityRectExtensions">
            <summary>Ad-hoc xxtentions to the Rect structure, used by Cinemachine</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityRectExtensions.Inflated(UnityEngine.Rect,UnityEngine.Vector2)">
            <summary>Inflate a rect</summary>
            <param name="r"></param>
            <param name="delta">x and y are added/subtracted fto/from the edges of
            the rect, inflating it in all directions</param>
            <returns>The inflated rect</returns>
        </member>
        <member name="T:Cinemachine.CinemachineExtension">
            <summary>
            Base class for a Cinemachine Virtual Camera extension module.
            Hooks into the Cinemachine Pipeline.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineExtension.Epsilon">
            <summary>Useful constant for very small floats</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExtension.VirtualCamera">
            <summary>Get the associated CinemachineVirtualCameraBase</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.Awake">
            <summary>Connect to virtual camera pipeline.
            Override implementations must call this base implementation</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.OnDestroy">
            <summary>Disconnect from virtual camera pipeline.
            Override implementations must call this base implementation</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>
            This callback will be called after the virtual camera has implemented
            each stage in the pipeline.  This method may modify the referenced state.
            If deltaTime less than 0, reset all state info and perform no damping. 
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.GetExtraState``1(Cinemachine.ICinemachineCamera)">
            <summary>Because extensions can be placed on manager cams and will in that
            case be called for all the vcam children, vcam-specific state information
            should be stored here.  Just define a class to hold your state info
            and use it exclusively when calling this.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.GetAllExtraStates``1">
            <summary>Ineffeicient method to get all extra state infor for all vcams.  
            Intended for Editor use only, not runtime!
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase">
            <summary>Abstract base class for a world-space path,
            suitable for a camera dolly track.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.m_Resolution">
            <summary>Path samples per waypoint</summary>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase.Appearance">
            <summary>This class holds the settings that control how the path
            will appear in the editor scene view.  The path is not visible in the game view</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.m_Appearance">
            <summary>The settings that control how the path
            will appear in the editor scene view.</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizePos(System.Single)">
            <summary>Get a normalized path position, taking spins into account if looped</summary>
            <param name="pos">Position along the path</param>
            <returns>Normalized position, between MinPos and MaxPos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.FindClosestPoint(UnityEngine.Vector3,System.Int32,System.Int32,System.Int32)">
            <summary>Find the closest point on the path to a given worldspace target point.</summary>
            <remarks>Performance could be improved by checking the bounding polygon of each segment,
            and only entering the best segment(s)</remarks>
            <param name="p">Worldspace target that we want to approach</param>
            <param name="startSegment">In what segment of the path to start the search.
            A Segment is a section of path between 2 waypoints.</param>
            <param name="searchRadius">How many segments on either side of the startSegment
            to search.  -1 means no limit, i.e. search the entire path</param>
            <param name="stepsPerSegment">We search a segment by dividing it into this many
            straight pieces.  The higher the number, the more accurate the result, but performance
            is proportionally slower for higher numbers</param>
            <returns>The position along the path that is closest to the target point.  
            The value is in Path Units, not Distance units.</returns>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase.PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.PositionUnits.PathUnits">
            <summary>Use PathPosition units, where 0 is first waypoint, 1 is second waypoint, etc</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.PositionUnits.Distance">
            <summary>Use Distance Along Path.  Path will be sampled according to its Resolution
            setting, and a distance lookup table will be cached internally</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.MinUnit(Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the minimum value, for the given unity type</summary>
            <param name="units">The uniot type</param>
            <returns>The minimum allowable value for this path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.MaxUnit(Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the maximum value, for the given unity type</summary>
            <param name="units">The uniot type</param>
            <returns>The maximum allowable value for this path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizeUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Normalize the unit, so that it lies between MinUmit and MaxUnit</summary>
            <param name="pos">The value to be normalized</param>
            <param name="units">The unit type</param>
            <returns>The normalized value of pos, between MinUnit and MaxUnit</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluatePositionAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateTangentAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateOrientationAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space orientation of the path</returns>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.InvalidateDistanceCache">
            <summary>Call this if the path changes in such a way as to affect distances
            or other cached path elements</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.DistanceCacheIsValid">
            <summary>See whether the distance cache is valid.  If it's not valid,
            then any call to GetPathLength() or GetPathPositionFromDistance() will
            trigger a potentially costly regeneration of the path distance cache</summary>
            <param name="stepsPerSegment">The number of steps to take between path points</param>
            <returns>Whether the cache is valid for this sampling rate</returns>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.PathLength">
            <summary>Get the length of the path in distance units.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizePathDistance(System.Single)">
            <summary>Normalize a distance along the path based on the path length.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <param name="distance">The distance to normalize</param>
            <returns>The normalized distance, ranging from 0 to path length</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.GetPathPositionFromDistance(System.Single)">
            <summary>Get the path position (in path units) corresponding to this distance along the path.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.GetPathDistanceFromPosition(System.Single)">
            <summary>Get the path position (in path units) corresponding to this distance along the path.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="T:Cinemachine.LensSettingsPropertyAttribute">
            <summary>
            Property applied to LensSettings.  Used for custom drawing in the inspector.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinitionPropertyAttribute">
            <summary>
            Property applied to CinemachineBlendDefinition.  Used for custom drawing in the inspector.
            </summary>
        </member>
        <member name="T:Cinemachine.SaveDuringPlayAttribute">
            <summary>
            Invoke play-mode-save for a class.  This class's fields will be scanned
            upon exiting play mode, and its property values will be applied to the scene object.
            This is a stopgap measure that will become obsolete once Unity implements
            play-mode-save in a more general way.
            </summary>
        </member>
        <member name="T:Cinemachine.NoSaveDuringPlayAttribute">
            <summary>
            Suppresses play-mode-save for a field.  Use it if the calsee has [SaveDuringPlay] 
            attribute but there are fields in the class that shouldn't be saved.
            </summary>
        </member>
        <member name="T:Cinemachine.TagFieldAttribute">
            <summary>Property field is a Tag.</summary>
        </member>
        <member name="T:Cinemachine.DocumentationSortingAttribute">
            <summary>
            Atrtribute to control the automatic generation of documentation.
            </summary>
        </member>
        <member name="T:Cinemachine.DocumentationSortingAttribute.Level">
            <summary>Refinement level of the documentation</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.Undoc">
            <summary>Type is excluded from documentation</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.API">
            <summary>Type is documented in the API reference</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.UserRef">
            <summary>Type is documented in the highly-refined User Manual</summary>
        </member>
        <member name="P:Cinemachine.DocumentationSortingAttribute.SortOrder">
            <summary>Where this type appears in the manual.  Smaller number sort earlier.</summary>
        </member>
        <member name="P:Cinemachine.DocumentationSortingAttribute.Category">
            <summary>Refinement level of the documentation.  The more refined, the more is excluded.</summary>
        </member>
        <member name="M:Cinemachine.DocumentationSortingAttribute.#ctor(System.Single,Cinemachine.DocumentationSortingAttribute.Level)">
            <summary>Contructor with specific values</summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCameraBase">
             <summary>
             Base class for a Monobehaviour that represents a Virtual Camera within the Unity scene.
            
             This is intended to be attached to an empty Transform GameObject.
             Inherited classes can be either standalone virtual cameras such
             as CinemachineVirtualCamera, or meta-cameras such as
             CinemachineClearShot or CinemachineFreeLook.
            
             A CinemachineVirtualCameraBase exposes a Priority property.  When the behaviour is
             enabled in the game, the Virtual Camera is automatically placed in a queue
             maintained by the static CinemachineCore singleton.
             The queue is sorted by priority.  When a Unity camera is equipped with a
             CinemachineBrain behaviour, the brain will choose the camera
             at the head of the queue.  If you have multiple Unity cameras with CinemachineBrain
             behaviours (say in a split-screen context), then you can filter the queue by
             setting the culling flags on the virtual cameras.  The culling mask of the
             Unity Camera will then act as a filter for the brain.  Apart from this,
             there is nothing that prevents a virtual camera from controlling multiple
             Unity cameras simultaneously.
             </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.CinemachineGUIDebuggerCallback">
            <summary>This is deprecated.  It is here to support the soon-to-be-removed
            Cinemachine Debugger in the Editor.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_ExcludedPropertiesInInspector">
            <summary>Inspector control - Use for hiding sections of the Inspector UI.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_LockStageInInspector">
            <summary>Inspector control - Use for enabling sections of the Inspector UI.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.ValidatingStreamVersion">
            <summary>Version that was last streamed, for upgrading legacy</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_Priority">
            <summary>The priority will determine which camera becomes active based on the
            state of other cameras and this camera.  Higher numbers have greater priority.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.AddPostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>
            A delegate to hook into the state calculation pipeline.
            This will be called after each pipeline stage, to allow others to hook into the pipeline.
            See CinemachineCore.Stage.
            </summary>
            <param name="d">The delegate to call.</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate">
            <summary>
            A delegate to hook into the state calculation pipeline.
            This will be called after each pipeline stage, to allow other
            services to hook into the pipeline.
            See CinemachineCore.Stage.
            
            Parameters:
            
            * CinemachineVirtualCameraBase vcam: the virtual camera being updated
            * CinemachineCore.Stage stage: what stage in the pipeline has just been updated
            * ref CameraState newState: the current state of the vcam
            * float deltaTime: the frame timestep.  Less than 0 means "don't consider the previous frame"
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStage">
            <summary>
            A delegate to hook into the state calculation pipeline.
            Implementaion must be sure to call this after each pipeline stage, to allow
            other services to hook into the pipeline.
            See CinemachineCore.Stage.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.InvokePostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>
            Invokes the PostPipelineStageDelegate for this camera, and up the hierarchy for all
            parent cameras (if any).
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Name">
            <summary>Get the name of the Virtual Camera.  Base implementation
            returns the owner GameObject's name.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Priority">
            <summary>Get the Priority of the virtual camera.  This determines its placement
            in the CinemachineCore's queue of eligible shots.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.VirtualCameraGameObject">
            <summary>The GameObject owner of the Virtual Camera behaviour.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.State">
            <summary>The CameraState object holds all of the information
            necessary to position the Unity camera.  It is the output of this class.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.LiveChildOrSelf">
            <summary>Just returns self.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.ParentCamera">
            <summary>Support for meta-virtual-cameras.  This is the situation where a
            virtual camera is in fact the public face of a private army of virtual cameras, which
            it manages on its own.  This method gets the VirtualCamera owner, if any.
            Private armies are implemented as Transform children of the parent vcam.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.  
            This base class implementation always returns false.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.LookAt">
            <summary>Get the LookAt target for the Aim component in the CinemachinePipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Follow">
            <summary>Get the Follow target for the Body component in the CinemachinePipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.PreviousStateIsValid">
            <summary>Set this to force the next update to ignore deltaTime and reset itself</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  
            Do not call this method.  Let the framework do it at the appropriate time</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>Notification that this virtual camera is going live.
            Base class implementationmust be called by any overridden method.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.Start">
            <summary>Base class implementation does nothing.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnDestroy">
            <summary>Base class implementation removes the virtual camera from the priority queue.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.  
            Call base class implementation at the beginning of overridden method.
            After base method is called, ValidatingStreamVersion will be valid.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnEnable">
            <summary>Base class implementation adds the virtual camera from the priority queue.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnDisable">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.Update">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnTransformParentChanged">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnGUI">
            <summary>Support for the deprecated CinemachineDebugger.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.ResolveLookAt(UnityEngine.Transform)">
            <summary>Returns this vcam's LookAt target, or if that is null, will retrun
            the parent vcam's LookAt target.</summary>
            <param name="localLookAt">This vcam's LookAt value.</param>
            <returns>The same value, or the parent's if null and a parent exists.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.ResolveFollow(UnityEngine.Transform)">
            <summary>Returns this vcam's Follow target, or if that is null, will retrun
            the parent vcam's Follow target.</summary>
            <param name="localFollow">This vcam's Follow value.</param>
            <returns>The same value, or the parent's if null and a parent exists.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.MoveToTopOfPrioritySubqueue">
            <summary>When multiple virtual cameras have the highest priority, there is
            sometimes the need to push one to the top, making it the current Live camera if 
            it shares the highest priority in the queue with its peers.  
            
            This happens automatically when a 
            new vcam is enabled: the most recent one goes to the top of the priority subqueue.  
            Use this method to push a vcam to the top of its priority peers.  
            If it and its peers share the highest priority, then this vcam will become Live.</summary>
        </member>
        <member name="T:Cinemachine.ICinemachineCamera">
            <summary>
            An abstract representation of a virtual camera which lives within the Unity scene
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Name">
            <summary>
            Gets the name of this virtual camera. For use when deciding how to blend
            to or from this camera
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Description">
            <summary>
            Gets a brief debug description of this virtual camera, for use when displayiong debug info
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Priority">
            <summary>
            Gets the priority of this <c>ICinemachineCamera</c>. The virtual camera
            will be inserted into the global priority stack based on this value.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.LookAt">
            <summary>
            The thing the camera wants to look at (aim).  May be null.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Follow">
            <summary>
            The thing the camera wants to follow (moving camera).  May be null.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.State">
            <summary>
            Camera state at the current time.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.VirtualCameraGameObject">
            <summary>
            Gets the virtual camera game attached to this class.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.LiveChildOrSelf">
            <summary>For cameras that implement child cameras, return the live child,
            otherwise, just returns self.</summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.ParentCamera">
            <summary>
            For cameras that implement child cameras, returns the parent vcam, otherwise null.
            </summary>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam is a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>
            Updates this Cinemachine Camera. For an active camera this should be
            called once and only once each frame.  To guarantee this, you should never
            call this method directly.  Always use
            CinemachineCore.UpdateVirtualCamera(ICinemachineCamera, float), which
            has protection against multiple calls per frame.
            </summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>
            Notification that a new camera is being activated.  This is sent to the
            currently active camera.  Both may be active simultaneously for a while, if blending.
            </summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="T:Cinemachine.LensSettings">
            <summary>
            Describes the FOV and clip planes for a camera.  This generally mirrors the Unity Camera's 
            lens settings, and will be used to drive the Unity camera when the vcam is active.
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.Default">
            <summary>Default Lens Settings</summary>
        </member>
        <member name="F:Cinemachine.LensSettings.FieldOfView">
            <summary>
            This is the camera view in vertical degrees. For cinematic people, a 50mm lens
            on a super-35mm sensor would equal a 19.6 degree FOV
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.OrthographicSize">
            <summary>
            When using an orthographic camera, this defines the height, in world 
            co-ordinates, of the camera view.
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.NearClipPlane">
            <summary>
            The near clip plane for this LensSettings
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.FarClipPlane">
            <summary>
            The far clip plane for this LensSettings
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.Dutch">
            <summary>
            The dutch (tilt) to be applied to the camera. In degrees
            </summary>
        </member>
        <member name="P:Cinemachine.LensSettings.Orthographic">
            <summary>
            This is set every frame by the virtual camera, based on the value found in the 
            currently associated Unity camera
            </summary>
        </member>
        <member name="P:Cinemachine.LensSettings.Aspect">
            <summary>
            This is set every frame by the virtual camera, based on the value 
            found in the currently associated Unity camera
            </summary>
        </member>
        <member name="M:Cinemachine.LensSettings.FromCamera(UnityEngine.Camera)">
            <summary>
            Creates a new LensSettings, copying the values from the 
            supplied Camera
            </summary>
            <param name="fromCamera">The Camera from which the FoV, near 
            and far clip planes will be copied.</param>
        </member>
        <member name="M:Cinemachine.LensSettings.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            Explicit constructor for this LensSettings
            </summary>
            <param name="fov">The Vertical field of view</param>
            <param name="orthographicSize">If orthographic, this is the half-height of the screen</param>
            <param name="nearClip">The near clip plane</param>
            <param name="farClip">The far clip plane</param>
            <param name="dutch">Camera roll, in degrees.  This is applied at the end 
            <param name="ortho">Whether the lens is orthographic</param>
            <param name="aspect">The aspect ratio of the lens  Width/height</param>
            after shot composition.</param>
        </member>
        <member name="M:Cinemachine.LensSettings.Lerp(Cinemachine.LensSettings,Cinemachine.LensSettings,System.Single)">
            <summary>
            Linearly blends the fields of two LensSettings and returns the result
            </summary>
            <param name="lensA">The LensSettings to blend from</param>
            <param name="lensB">The LensSettings to blend to</param>
            <param name="t">The interpolation value. Internally clamped to the range [0,1]</param>
            <returns>Interpolated settings</returns>
        </member>
        <member name="M:Cinemachine.LensSettings.Validate">
            <summary>Make sure lens settings are sane.  Call this from OnValidate().</summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings">
            <summary>
            This is an asset that defines a noise profile.  A noise profile is the 
            shape of the noise as a function of time.  You can build arbitrarily complex shapes by
            combining different base perlin noise frequencies at different amplitudes.
            
            The frequencies and amplitudes should be chosen with care, to ensure an interesting
            noise quality that is not obviously repetitive.
            
            As a mathematical side-note, any arbitrary periodic curve can be broken down into a 
            series of fixed-amplitude sine-waves added together.  This is called fourier decomposition,
            and is the basis of much signal processing.  It doesn't really have much to do with this
            asset, but it's super interesting!
            </summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings.NoiseParams">
            <summary>
            Describes the behaviour for a channel of noise
            </summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.NoiseParams.Amplitude">
            <summary>The amplitude of the noise for this channel.  Larger numbers vibrate higher</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.NoiseParams.Frequency">
            <summary>The frequency of noise for this channel.  Higher magnitudes vibrate faster</summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings.TransformNoiseParams">
            <summary>
            Contains the behaviour of noise for the noise module for all 3 cardinal axes of the camera
            </summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.X">
            <summary>Noise definition for X-axis</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.Y">
            <summary>Noise definition for Y-axis</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.Z">
            <summary>Noise definition for Z-axis</summary>
        </member>
        <member name="P:Cinemachine.NoiseSettings.PositionNoise">
            <summary>
            Gets the array of positional noise channels for this <c>NoiseSettings</c>
            </summary>
        </member>
        <member name="P:Cinemachine.NoiseSettings.OrientationNoise">
            <summary>
            Gets the array of orientation noise channels for this <c>NoiseSettings</c>
            </summary>
        </member>
        <member name="M:Cinemachine.NoiseSettings.CopyFrom(Cinemachine.NoiseSettings)">
            <summary>Clones the contents of the other asset into this one</summary>
        </member>
        <member name="T:Ferr2D_DynamicMesh">
            <summary>
            I recommend agains using this for your own mesh creation, it's a little quirky, and pretty specific
            to the path stuff in Ferr2DTerrain. But it's a utility to make mesh creation easier for the path stuff.
            </summary>
        </member>
        <member name="P:Ferr2D_DynamicMesh.VertCount">
            <summary>
            The number of vertices currently in the mesh.
            </summary>
        </member>
        <member name="M:Ferr2D_DynamicMesh.Clear">
            <summary>
            Clears all verices, indices, uvs, and colors from this mesh, resets color to white.
            </summary>
        </member>
        <member name="M:Ferr2D_DynamicMesh.Build(UnityEngine.Mesh@,System.Boolean)">
            <summary>
            Clears out the mesh, fills in the data, and recalculates normals and bounds.
            </summary>
            <param name="aMesh">An already existing mesh to fill out.</param>
        </member>
        <member name="M:Ferr2D_DynamicMesh.ExtrudeZ(System.Single,System.Boolean)">
            <summary>
            This extrude is pretty specific to the Ferr2DT path stuff, but it extrudes a 2D mesh out a certain
            distance, for use with collision meshes.
            </summary>
            <param name="aDist">How far on the Z axis to extrude.</param>
            <param name="aInverted">If this is the mesh of an inverted terrain, it should behave differently.</param>
        </member>
        <member name="M:Ferr2D_DynamicMesh.RemoveFaces(UnityEngine.Vector3,System.Single)">
            <summary>
            Removes any faces that match the given normal, within the tolerance specified. No verts are deleted, just faces.
            </summary>
            <param name="aFacing">Normalized direction to delete with</param>
            <param name="aDegreesTolerance">Angle of tolerance, in degrees</param>
        </member>
        <member name="M:Ferr2D_DynamicMesh.GetCurrentTriangleList(System.Int32)">
            <summary>
            Gets the current list of triangles.
            </summary>
            <param name="aStart">An offset to start from.</param>
            <returns></returns>
        </member>
        <member name="M:Ferr2D_DynamicMesh.GetVert(System.Int32)">
            <summary>
            Returns the vert at the indicated index. Index isn't checked for validity.
            </summary>
            <param name="aIndex">Value between 0 and number of verts in the mesh.</param>
            <returns>Vertex from the indicated index</returns>
        </member>
        <member name="T:Ferr2D_Path">
            <summary>
            A generic path with lots of helper functions. Should be useful for all sorts of things!
            </summary>
        </member>
        <member name="F:Ferr2D_Path.closed">
            <summary>
            If the path should connect at the ends! Influences interpolation, especially for normals.
            </summary>
        </member>
        <member name="F:Ferr2D_Path.pathVerts">
            <summary>
            If you really want access to these, you should call GetVerts
            </summary>
        </member>
        <member name="P:Ferr2D_Path.Count">
            <summary>
            Returns the number of vertices in the path
            </summary>
        </member>
        <member name="M:Ferr2D_Path.ReCenter">
            <summary>
            Moves the object location to the center of the path verts. Also offsets the path locations to match.
            </summary>
        </member>
        <member name="M:Ferr2D_Path.UpdateDependants(System.Boolean)">
            <summary>
            Updates all other component on this GameObject that implement the Ferr2DT_IPath interface.
            </summary>
        </member>
        <member name="M:Ferr2D_Path.UpdateColliders">
            <summary>
            Updates the colliders of all Ferr2DT_PathTerrain components attached to this object!
            </summary>
        </member>
        <member name="M:Ferr2D_Path.Add(UnityEngine.Vector2)">
            <summary>
            Adds a vertex to the end of the path.
            </summary>
            <param name="aPoint">The vertex to add!</param>
        </member>
        <member name="M:Ferr2D_Path.GetClosestSeg(UnityEngine.Vector2)">
            <summary>
            Gets the index of the path point that starts the closest line segment to the specified point.
            </summary>
            <param name="aPoint">The point to check from.</param>
            <returns>Index of the first point in the line segment, the other point would be Index+1</returns>
        </member>
        <member name="M:Ferr2D_Path.GetVertsRaw">
            <summary>
            Don't care about smoothing? If aSmoothed is false, GetVerts calls this method.
            </summary>
            <returns>Just a plain old copy of pathVerts.</returns>
        </member>
        <member name="M:Ferr2D_Path.GetVertsSmoothed(System.Single,System.Boolean,System.Boolean)">
            <summary>
            Gets a copy of the vertices that's smoothed.
            </summary>
            <param name="aSplitDistance">If they're smoothed, how far apart should each smooth split be?</param>
            <param name="aSplitCorners">Should we make corners sharp? Sharp corners don't get smoothed.</param>
            <returns>A copy of the smoothed data.</returns>
        </member>
        <member name="M:Ferr2D_Path.GetBounds">
            <summary>
            Finds a rectangle bounding the entire path, based on the raw vertex data.
            </summary>
            <returns>Floating point rectangle that goes up exactly to the edges of the raw path.</returns>
        </member>
        <member name="M:Ferr2D_Path.GetNormal(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Boolean)">
            <summary>
            Gets the normal at the specified path index.
            </summary>
            <param name="aSegment">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to get the normal of.</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr2D_Path.CubicGetNormal(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Single,System.Boolean)">
            <summary>
            Gets the normal at the specified path index using cubic interpolation for smoothing.
            </summary>
            <param name="aSegment">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to start from.</param>
            <param name="aPercentage">How far between this vertex and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized cubic interpolated normal!</returns>
        </member>
        <member name="M:Ferr2D_Path.CubicGetPt(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Single,System.Boolean)">
            <summary>
            
            </summary>
            <param name="aSegment">The list of vertices used to calculate the point.</param>
            <param name="i">Index of the vertex to start from.</param>
            <param name="aPercentage">How far between this vertex and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A cubic interpolated point.</returns>
        </member>
        <member name="M:Ferr2D_Path.HermiteGetNormal(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Single,System.Boolean,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="aSegment">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to start from.</param>
            <param name="aPercentage">How far between this vertex and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized Hermite interpolated normal!</returns>
        </member>
        <member name="M:Ferr2D_Path.HermiteGetPt(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Single,System.Boolean,System.Single,System.Single)">
            <param name="aSegment">The list of vertices used to calculate the point.</param>
            <param name="i">Index of the vertex to start from.</param>
            <param name="aPercentage">How far between this vertex and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A Hermite interpolated point.</returns>
        </member>
        <member name="M:Ferr2D_Path.HermiteGetPtTangent(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Single,System.Boolean,System.Single,System.Single)">
            <param name="aSegment">The list of vertices used to calculate the point.</param>
            <param name="i">Index of the vertex to start from.</param>
            <param name="aPercentage">How far between this vertex and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>The tangent at a Hermite interpolated point. (not normalized)</returns>
        </member>
        <member name="M:Ferr2D_Path.HermiteGetFloat(System.Collections.Generic.List{System.Single},System.Int32,System.Single,System.Boolean,System.Single,System.Single)">
            <param name="aSegment">The list of floats used to calculate the result.</param>
            <param name="i">Index of the float to start from.</param>
            <param name="aPercentage">How far between this float and the next should we look?</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>The tangent at a Hermite interpolated point. (not normalized)</returns>
        </member>
        <member name="M:Ferr2D_Path.GetDirection(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Gets the direction enum of a line segment.
            </summary>
            <param name="aOne">First vertex in the line segment.</param>
            <param name="aTwo">Second vertex in the line segment.</param>
            <returns>Direction enum!</returns>
        </member>
        <member name="M:Ferr2D_Path.GetDirection(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Boolean,System.Boolean,System.Collections.Generic.List{Ferr2DT_TerrainDirection})">
            <summary>
            Gets the direction enum of a line segment, invertable!
            </summary>
            <param name="aSegment">list of vertices to pick from</param>
            <param name="i">First vertex to use as the ine segment, next is i+1 (or i-1 if i+1 is outside the array)</param>
            <param name="aInvert">Flip the direction around?</param>
            <returns>Direction enum!</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ferr2D_Path.GetDirection(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{System.Int32},System.Int32,System.Boolean,System.Boolean,System.Collections.Generic.List{Ferr2DT_TerrainDirection})" -->
        <member name="M:Ferr2D_Path.IsSplit(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Collections.Generic.List{Ferr2DT_TerrainDirection})">
            <summary>
            Checks to see if a vertex is at a corner. Ends are not considered corners.
            </summary>
            <param name="aSegment">A list of vertices to pick from.</param>
            <param name="i">Index of the vertex we're checking.</param>
            <returns>Is it a corner? Ends are not corners.</returns>
        </member>
        <member name="M:Ferr2D_Path.GetSegments(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{Ferr2DT_TerrainDirection}@,System.Collections.Generic.List{Ferr2DT_TerrainDirection},System.Boolean,System.Boolean)">
            <summary>
            Splits a path up based on corners. Corner verts are included in both segments when split.
            </summary>
            <param name="aPath">The list of path points to split.</param>
            <returns>An array of path segments.</returns>
        </member>
        <member name="M:Ferr2D_Path.SmoothSegment(System.Collections.Generic.List{UnityEngine.Vector2},System.Single,System.Boolean)">
            <summary>
            Smooths a segment of path points.
            </summary>
            <param name="aSegment">The collection of points to smooth out.</param>
            <param name="aSplitDistance">How far should each smooth split be?</param>
            <param name="aClosed">Should we close the segment?</param>
            <returns>A new list of vertices.</returns>
        </member>
        <member name="M:Ferr2D_Path.SmoothSegment(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{System.Single},System.Single,System.Boolean,System.Collections.Generic.List{UnityEngine.Vector2}@,System.Collections.Generic.List{System.Single}@)">
            <summary>
            Smooths a segment of path points and scales.
            </summary>
            <param name="aSegment">The collection of points to smooth out.</param>
            <param name="aSplitDistance">How far should each smooth split be?</param>
            <param name="aClosed">Should we close the segment?</param>
        </member>
        <member name="M:Ferr2D_Path.CloseEnds(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{System.Collections.Generic.List{System.Int32}}@,System.Collections.Generic.List{Ferr2DT_TerrainDirection}@,System.Boolean,System.Boolean)">
            <summary>
            This method will close a list of split segments, merging and adding points to the end chunks.
            </summary>
            <param name="aSegmentList">List of split segments that make up the path.</param>
            <param name="aCorners">If there are corners or not.</param>
            <returns>A closed loop of segments.</returns>
        </member>
        <member name="M:Ferr2D_Path.IndicesToList``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{System.Int32})">
            <summary>
            Converts a list of indices to a list of data created from the given list.
            </summary>
            <param name="aPath">Path to pull data from</param>
            <param name="aIndices">List of indices to pull from the data.</param>
            <returns>A list of data as indicated by the index list</returns>
        </member>
        <member name="M:Ferr2D_Path.IndicesToPath(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{UnityEngine.Vector2}@,System.Collections.Generic.List{System.Single}@)">
            <summary>
            Converts a list of path indices to a list of path verts and scales created from the given list.
            </summary>
            <param name="aPath">Path to pull vert data from</param>
            <param name="aScales">List to pull scales data from</param>
            <param name="aIndices">List of inidces to pull from the path.</param>
        </member>
        <member name="M:Ferr2D_Path.GetClosetPointOnLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean)">
            <summary>
            A utility function! Gets the closest point on a line, clamped to the line segment provided.
            </summary>
            <param name="aStart">Start of the line segment.</param>
            <param name="aEnd">End of the line segment.</param>
            <param name="aPoint">The point to compare distance to.</param>
            <param name="aClamp">Should we clamp at the ends of the segment, or treat it as an infinite line?</param>
            <returns>The closest point =D</returns>
        </member>
        <member name="M:Ferr2D_Path.GetDistanceFromPath(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2,System.Boolean)">
            <summary>
            Gets the smallest distance to the provided path
            </summary>
            <param name="aPoint">The point to check from.</param>
            <returns>Smallest distance! float.MaxValue if none found</returns>
        </member>
        <member name="M:Ferr2D_Path.GetSegmentNormal(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the normal at the specified path segment.
            </summary>
            <param name="aPath">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the first vert of the segment.</param>
            <param name="aClosed">Should we wrap around as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr2D_Path.GetSegmentLength(System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Calculates the length of a path by summing the distances of its segments.
            </summary>
            <param name="aPath">A list of consecutive points.</param>
            <param name="aClosed">Should we include the segment between the first and the last point?</param>
            <returns>Length of the path, 0 if null or only one point.</returns>
        </member>
        <member name="T:Ferr2D_Triangulator">
            <summary>
            This thing can be better, but it'll do for now. It takes a list of points, and creates a 2D mesh describing it.
            </summary>
        </member>
        <member name="M:Ferr2D_Triangulator.GetIndices(System.Collections.Generic.List{UnityEngine.Vector2}@,System.Boolean,System.Boolean,UnityEngine.Vector2,System.Single)">
            <summary>
            Creates a triangulation of the vertices given, and gives you the indices of it.
            </summary>
            <param name="aPoints">A list of points to triangulate.</param>
            <param name="aTreatAsPath">Should we discard any triangles at all? Use this if you want to get rid of triangles that are outside the path.</param>
            <param name="aInvert">if we're treating it as a path, should we instead sicard triangles inside the path?</param>
            <param name="aInvertBorderSize">When inverted, how large should the border be in each direction?</param>
            <returns>A magical list of indices describing the triangulation!</returns>
        </member>
        <member name="M:Ferr2D_Triangulator.GetSegmentsUnder(System.Collections.Generic.List{UnityEngine.Vector2},System.Single,System.Single,System.Boolean)">
            <summary>
            Gets a list of line segments that are under the given point. Two indices per segment.
            </summary>
            <param name="aPath">A list of path vertices.</param>
            <param name="aX">The point.</param>
            <param name="aY">The point</param>
            <param name="aIgnoreLast">Ignore the last 4 vertices, often useful since triangulation involves adding 4 verts to the end of the path list.</param>
            <returns></returns>
        </member>
        <member name="M:Ferr2D_Triangulator.GetBounds(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Gets a bounding rectangle based on the given points
            </summary>
            <param name="aPoints">List of points.</param>
            <returns>x = left, y = top, z = right, w = bottom</returns>
        </member>
        <member name="M:Ferr2D_Triangulator.PtInTri(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Is the given point inside a 2D triangle?
            </summary>
            <param name="aTri1">Triangle point 1</param>
            <param name="aTri2">Triangle point 2</param>
            <param name="aTri3">Triangle point 9001</param>
            <param name="aPt">The point to test!</param>
            <returns>IS IT INSIDE YET?</returns>
        </member>
        <member name="M:Ferr2D_Triangulator.LineIntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Gets the point where two lines intersect, really useful for determining the circumcenter.
            </summary>
            <param name="aStart1">Line 1 start</param>
            <param name="aEnd1">Line 1 llamma</param>
            <param name="aStart2">Line 2 start</param>
            <param name="aEnd2">Line 2 end</param>
            <returns>WHERE THEY INTERSECT</returns>
        </member>
        <member name="M:Ferr2D_Triangulator.IsClockwise(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Determines if these points are in clockwise order.
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.P2T.Warmup">
            <summary>
            Will do a warmup run to let the JVM optimize the triangulation code -- or would if this were Java --MM
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.MarkNeighbor(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.DelaunayTriangle)">
            <summary>
            Update neighbor pointers
            </summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.MarkNeighbor(FerrPoly2Tri.DelaunayTriangle)">
            <summary>
            Exhaustive search to update neighbor pointers
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.Clear">
            <summary>
            Clears all references to all other triangles and points
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.OppositePoint(FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.Legalize(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Legalize triangle by rotating clockwise around oPoint
            </summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.MarkNeighborEdges">
            <summary>
            Finalize edge marking
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.MarkConstrainedEdge(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Mark edge as constrained
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DelaunayTriangle.EdgeIndex(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
            </summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="T:FerrPoly2Tri.AdvancingFront">
            @author Thomas Åhlen (thahlen@gmail.com)
        </member>
        <member name="M:FerrPoly2Tri.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
            MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                 Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.AdvancingFront.LocateNode(FerrPoly2Tri.TriangulationPoint)">
            <summary>
            We use a balancing tree to locate a node smaller or equal to given key value (in theory)
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.AdvancingFront.LocatePoint(FerrPoly2Tri.TriangulationPoint)">
            <summary>
            This implementation will use simple node traversal algorithm to find a point on the front
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.Triangulate(FerrPoly2Tri.DTSweepContext)">
            <summary>
            Triangulate simple polygon with holes
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.Sweep(FerrPoly2Tri.DTSweepContext)">
            <summary>
            Start sweeping the Y-sorted point set from bottom to top
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.FinalizationConvexHull(FerrPoly2Tri.DTSweepContext)">
            <summary>
            If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull 
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.TurnAdvancingFrontConvex(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.AdvancingFrontNode,FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            We will traverse the entire advancing front and fill it to form a convex hull.
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.FinalizationConstraints(FerrPoly2Tri.DTSweepContext)">
             <summary>
             NOTE: WORK IN PROGRESS - for now this will just clean out all triangles from
             inside the outermost holes without paying attention to holes within holes..
             hence the work in progress :)
             
             Removes triangles inside "holes" (that are not inside of other holes already)
             
             In the example below, assume that triangle ABC is a user-defined "hole".  Thus
             any triangles inside it (that aren't inside yet another user-defined hole inside
             triangle ABC) should get removed.  In this case, since there are no user-defined
             holes inside ABC, we would remove triangles ADE, BCE, and CDE.  We would also 
             need to combine the appropriate edges so that we end up with just triangle ABC
            
                      E
             A +------+-----+ B              A +-----------+ B
                \    /|    /                    \         /
                 \  / |   /                      \       /
                D +   |  /        ======>         \     /
                   \  | /                          \   /
                    \ |/                            \ /
                      +                              +
                      C                              C
                      
             </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.PointEvent(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Find closes node to the left of the new point and
            create a new triangle. If needed new holes and basins
            will be filled to.
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.NewFrontTriangle(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            Creates a new front triangle and legalize it
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.NextFlipPoint(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint@)">
            <summary>
            When we need to traverse from one triangle to the next we need 
            the point in current triangle that is the opposite point to the next
            triangle. 
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.NextFlipTriangle(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.Orientation,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            After a flip we have two triangles and know that only one will still be
            intersecting the edge. So decide which to contiune with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FerrPoly2Tri.DTSweep.FlipScanEdgeEvent(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint)" -->
        <member name="M:FerrPoly2Tri.DTSweep.FillAdvancingFront(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            Fills holes in the Advancing Front
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FerrPoly2Tri.DTSweep.FillBasin(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.AdvancingFrontNode)" -->
        <member name="M:FerrPoly2Tri.DTSweep.FillBasinReq(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            Recursive algorithm to fill a Basin with triangles
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.HoleAngle(FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            ???
            </summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.BasinAngle(FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            The basin angle is decided against the horizontal line [1,0]
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.Fill(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.AdvancingFrontNode)">
            <summary>
            Adds a triangle to the advancing front to fill a hole.
            </summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.Legalize(FerrPoly2Tri.DTSweepContext,FerrPoly2Tri.DelaunayTriangle)">
            <summary>
            Returns true if triangle was legalized
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweep.RotateTrianglePair(FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.DelaunayTriangle,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Rotates a triangle pair one vertex CW
                  n2                    n2
             P +-----+             P +-----+
               | t  /|               |\  t |  
               |   / |               | \   |
             n1|  /  |n3           n1|  \  |n3
               | /   |    after CW   |   \ |
               |/ oT |               | oT \|
               +-----+ oP            +-----+
                  n4                    n4
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.DTSweepConstraint.#ctor(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Give two points in any order. Will always be ordered so
            that q.y > p.y and q.x > p.x if same y value 
            </summary>
        </member>
        <member name="T:FerrPoly2Tri.DTSweepContext">
             
             @author Thomas Åhlén, thahlen@gmail.com
            
        </member>
        <member name="M:FerrPoly2Tri.DTSweepContext.MapTriangleToNodes(FerrPoly2Tri.DelaunayTriangle)">
            <summary>
            Try to map a node to all sides of this triangle that don't have 
            a neighbor.
            </summary>
        </member>
        <member name="T:FerrPoly2Tri.Contour">
            <summary>
            This is basically a light-weight version of the Polygon class, but with limited functionality and
            used for different purposes.   Nonetheless, for all intents and purposes, this should actually be
            a polygon (though not a Polygon..)
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.Contour.GetNumHoles(System.Boolean)">
            <summary>
            returns number of holes that are actually holes, including all children of children, etc.   Does NOT
            include holes that are not actually holes.   For example, if the parent is not a hole and this contour has
            a hole that contains a hole, then the number of holes returned would be 2 - one for the current hole (because
            the parent is NOT a hole and thus this hole IS a hole), and 1 for the child of the child.
            </summary>
            <param name="parentIsHole"></param>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Contour.GetNumHoles">
            <summary>
            returns the basic number of child holes of THIS contour, not including any children of children, etc nor
            examining whether any children are actual holes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.#ctor(System.Collections.Generic.IList{FerrPoly2Tri.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.#ctor(System.Collections.Generic.IEnumerable{FerrPoly2Tri.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.#ctor(FerrPoly2Tri.PolygonPoint[])">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.RemovePoint(FerrPoly2Tri.PolygonPoint)">
            <summary>
            Removes a point from the polygon.  Note this can be a somewhat expensive operation
            as it must recalculate the bounding area from scratch.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.AddHole(FerrPoly2Tri.Polygon)">
            <summary>
            Add a hole to the polygon.
            </summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:FerrPoly2Tri.Polygon.Prepare(FerrPoly2Tri.TriangulationContext)">
            <summary>
            Creates constraints and populates the context with points
            </summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:FerrPoly2Tri.PolygonUtil.PolygonsAreSame2D(System.Collections.Generic.IList{FerrPoly2Tri.Point2D},System.Collections.Generic.IList{FerrPoly2Tri.Point2D})">
            <summary>
            Check if the polys are similar to within a tolerance (Doesn't include reflections,
            but allows for the points to be numbered differently, but not reversed).
            </summary>
            <param name="poly1"></param>
            <param name="poly2"></param>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonUtil.PolygonContainsPolygon(System.Collections.Generic.IList{FerrPoly2Tri.Point2D},FerrPoly2Tri.Rect2D,System.Collections.Generic.IList{FerrPoly2Tri.Point2D},FerrPoly2Tri.Rect2D,System.Boolean)">
             <summary>
             Checks to see if poly1 contains poly2.  return true if so, false otherwise.
            
             If the polygons intersect, then poly1 cannot contain poly2 (or vice-versa for that matter)
             Since the poly intersection test can be somewhat expensive, we'll only run it if the user
             requests it.   If runIntersectionTest is false, then it is assumed that the user has already
             verified that the polygons do not intersect.  If the polygons DO intersect and runIntersectionTest
             is false, then the return value is meaningless.  Caveat emptor.
             
             As an added bonus, just to cause more user-carnage, if runIntersectionTest is false, then the 
             boundRects are not used and can safely be passed in as nulls.   However, if runIntersectionTest
             is true and you pass nulls for boundRect1 or boundRect2, you will cause a program crash.
             
             Finally, the polygon points are assumed to be passed in Clockwise winding order.   It is possible
             that CounterClockwise ordering would work, but I have not verified the behavior in that case. 
             
             </summary>
             <param name="poly1">points of polygon1</param>
             <param name="boundRect1">bounding rect of polygon1.  Only used if runIntersectionTest is true</param>
             <param name="poly2">points of polygon2</param>
             <param name="boundRect2">bounding rect of polygon2.  Only used if runIntersectionTest is true</param>
             <param name="runIntersectionTest">see summary above</param>
             <returns>true if poly1 fully contains poly2</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FerrPoly2Tri.PolygonUtil.PolygonUnion(FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList@)" -->
        <member name="M:FerrPoly2Tri.PolygonUtil.PolygonIntersect(FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList@)">
            <summary>
            Finds the intersection between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="intersectOut">The intersection of the two polygons</param>
            <returns>error code</returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonUtil.PolygonSubtract(FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList@)">
            <summary>
            Subtracts one polygon from another.
            </summary>
            <param name="polygon1">The base polygon.</param>
            <param name="polygon2">The polygon to subtract from the base.</param>
            <param name="subtract">The result of the polygon subtraction</param>
            <returns>error code</returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonUtil.PolygonOperation(FerrPoly2Tri.PolygonUtil.PolyOperation,FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList,System.Collections.Generic.Dictionary{System.UInt32,FerrPoly2Tri.Point2DList}@)">
            <summary>
            Performs one or more polygon operations on the 2 provided polygons
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon</param>
            <param name="subtract">The result of the polygon subtraction</param>
            <returns>error code</returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonUtil.SplitComplexPolygon(FerrPoly2Tri.Point2DList,System.Double)">
             <summary>
             Trace the edge of a non-simple polygon and return a simple polygon.
             
            Method:
            Start at vertex with minimum y (pick maximum x one if there are two).  
            We aim our "lastDir" vector at (1.0, 0)
            We look at the two rays going off from our start vertex, and follow whichever
            has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
            
            Loop until we hit starting vertex:
            
            We add our current vertex to the list.
            We check the seg from current vertex to next vertex for intersections
              - if no intersections, follow to next vertex and continue
              - if intersections, pick one with minimum distance
                - if more than one, pick one with "rightest" next point (two possibilities for each)
                
             </summary>
             <param name="verts"></param>
             <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonOperationContext.VerticesIntersect(FerrPoly2Tri.Point2DList,FerrPoly2Tri.Point2DList,System.Collections.Generic.List{FerrPoly2Tri.EdgeIntersectInfo}@)">
            <summary>
            Check and return polygon intersections
            </summary>
            <param name="polygon1"></param>
            <param name="polygon2"></param>
            <param name="intersections"></param>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.PolygonOperationContext.PointInPolygonAngle(FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2DList)">
            <summary>
            * ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            * Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            * If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.PolygonOperationContext.VectorAngle(FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.TriangulationConstraint.#ctor(FerrPoly2Tri.TriangulationPoint,FerrPoly2Tri.TriangulationPoint)">
            <summary>
            Give two points in any order. Will always be ordered so
            that q.y > p.y and q.x > p.x if same y value 
            </summary>
        </member>
        <member name="T:FerrPoly2Tri.TriangulationUtil">
            @author Thomas Åhlén, thahlen@gmail.com
        </member>
        <member name="M:FerrPoly2Tri.TriangulationUtil.SmartIncircle(FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D)">
            <summary>
              Requirements:
            1. a,b and c form a triangle.
            2. a and d is know to be on opposite side of bc
            <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
               Facts:
             d has to be in area B to have a chance to be inside the circle formed by a,b and c
             d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
             This preknowledge gives us a way to optimize the incircle test
            </summary>
            <param name="pa">triangle point, opposite d</param>
            <param name="pb">triangle point</param>
            <param name="pc">triangle point</param>
            <param name="pd">point opposite a</param>
            <returns>true if d is inside circle, false if on circle edge</returns>
        </member>
        <member name="M:FerrPoly2Tri.TriangulationUtil.Orient2d(FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                         =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
        <member name="M:FerrPoly2Tri.TriangulationUtil.LinesIntersect2D(FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,FerrPoly2Tri.Point2D,System.Boolean,System.Boolean,System.Boolean,FerrPoly2Tri.Point2D@,System.Double)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="ptStart0">The first point of the first line segment.</param>
            <param name="ptEnd0">The second point of the first line segment.</param>
            <param name="ptStart1">The first point of the second line segment.</param>
            <param name="ptEnd1">The second point of the second line segment.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <param name="coincidentEndPointCollisions">Set this to true to enable collisions if the line segments share
            an endpoint</param>
            <param name="pIntersectionPt">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="F:FerrPoly2Tri.Point2DList.kLinearSlop">
            A small length used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
        </member>
        <member name="F:FerrPoly2Tri.Point2DList.kAngularSlop">
            A small angle used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.GetSignedArea">
            <summary>
            Gets the signed area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.GetArea">
            <summary>
            Gets the area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.GetCentroid">
            <summary>
            Gets the centroid.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FerrPoly2Tri.Point2DList.Translate(FerrPoly2Tri.Point2D)" -->
        <member name="M:FerrPoly2Tri.Point2DList.Scale(FerrPoly2Tri.Point2D)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.Rotate(System.Double)">
            <summary>
            Rotate the vertices with the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.IsConvex">
            <summary>
            Assuming the polygon is simple; determines whether the polygon is convex.
            </summary>
            <returns>
              <c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.IsSimple">
            <summary>
            Check for edge crossings
            </summary>
            <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.CheckPolygon">
             <summary>
             Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
            
             From Eric Jordan's convex decomposition library
             </summary>
             <param name="printErrors"></param>
             <returns></returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.RemoveDuplicateNeighborPoints">
            <summary>
            Removes duplicate points that lie next to each other in the list
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.Simplify">
            <summary>
            Removes all collinear points on the polygon.
            Has a default bias of 0
            </summary>
            <param name="polygon">The polygon that needs simplification.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.Simplify(System.Double)">
            <summary>
            Removes all collinear points on the polygon.   Note that this is NOT safe to run on a complex
            polygon as it will remove points that it should not.   For example, consider this polygon:
            
                      2
                      +
                     / \
                    /   \
                   /     \
            0 +---+-------+
                  3       1
            
            This algorithm would delete point 3, leaving you with the polygon 0,1,2 - definitely NOT the correct
            polygon.  Caveat Emptor!
            
            </summary>
            <param name="polygon">The polygon that needs simplification.</param>
            <param name="bias">The distance bias between points. Points closer than this will be 'joined'.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.MergeParallelEdges(System.Double)">
            <summary>
            Merges all parallel edges in the list of vertices
            </summary>
            <param name="tolerance"></param>
        </member>
        <member name="M:FerrPoly2Tri.Point2DList.ProjectToAxis(FerrPoly2Tri.Point2D,System.Double@,System.Double@)">
            <summary>
            Projects to axis.
            </summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:FerrPoly2Tri.Rect2D.Contains(System.Double,System.Double)">
            <summary>
            Returns whether the coordinate is inside the bounding box.  Note that this will return
            false if the point is ON the edge of the bounding box.  If you want to test for whether
            the point is inside OR on the rect, use ContainsInclusive
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.Rect2D.ContainsInclusive(System.Double,System.Double)">
            <summary>
            Returns whether the coordinate is inside the bounding box.  Note that this will return
            false if the point is ON the edge of the bounding box.  If you want to test for whether
            the point is inside OR on the rect, use ContainsInclusive
            </summary>
        </member>
        <member name="M:FerrPoly2Tri.Rect2D.Intersection(FerrPoly2Tri.Rect2D,FerrPoly2Tri.Rect2D)">
             Intersection
            
             Sets the rectangle to the intersection of two rectangles. 
             Returns true if there is any intersection between the two rectangles.
             If there is no intersection, the rectangle is set to 0, 0, 0, 0.
             Either of the input rectangles may be the same as destination rectangle.
            
        </member>
        <member name="M:FerrPoly2Tri.Rect2D.Union(FerrPoly2Tri.Rect2D,FerrPoly2Tri.Rect2D)">
             Union
            
             Sets the rectangle to the union of two rectangles r1 and r2. 
             If either rect is empty, it is ignored. If both are empty, the rectangle
             is set to r1.
             Either of the input rectangle references may refer to the destination rectangle.
            
        </member>
        <member name="T:Ferr.LambdaComparer`1">
            <summary>
            A generic IComparer, primarily for sorting mesh segments by z value, to avoid overlap and Z issues.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Ferr.PathUtil.IsClockwise(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Checks if a closed polygon's points are in clockwise order.
            </summary>
            <param name="aPoly">A closed polygon.</param>
            <returns>True if clockwise, false if counter-clockwise.</returns>
        </member>
        <member name="M:Ferr.PathUtil.SortPointsClockwise(System.Collections.Generic.List{UnityEngine.Vector2}@)">
            <summary>
            Sorts a cloud of points into a clockwise order. The center of the cloud is determined by averaging the points.
            </summary>
            <param name="aPoints">A list of points that will be modified into a clockwise order around the averaged center.</param>
        </member>
        <member name="M:Ferr.PathUtil.SortPointsClockwise(System.Collections.Generic.List{UnityEngine.Vector2}@,UnityEngine.Vector2)">
            <summary>
            Sorts a cloud of points into a clockwise order around the provided center.
            </summary>
            <param name="aCenter">The center point of the circle, with which to sort the points around.</param>
            <param name="aPoints">A list of points that will be modified into a clockwise order around the provided center.</param>
        </member>
        <member name="M:Ferr.PathUtil.GetLength(System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            <summary>
            Finds the distance along the path from the start to the end, including the closing segment if marked as closed.
            </summary>
            <param name="aPath">The path to find the length of.</param>
            <param name="aClosed">Is the path closed? Should the closing segment also be considered?</param>
            <returns>Total length of the given path.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetLength(System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Finds the distance along the path from the start to the end, including the closing segment if marked as closed.
            </summary>
            <param name="aPath">The path to find the length of.</param>
            <param name="aClosed">Is the path closed? Should the closing segment also be considered?</param>
            <returns>Total length of the given path.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetBounds(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector4)">
            <summary>
            Finds a 2D rectangle that encloses the entire list of points.
            </summary>
            <param name="aPoints">List of points to enclose.</param>
            <param name="aPadding">This padding is added to the final rectangle. Positive values will inflate size, negative values will shrink size. xMin-=x, yMax+=y, xMax+=z, yMin-=w</param>
            <returns>A rectangle enclosing the list of points, modified by the padding.</returns>
        </member>
        <member name="M:Ferr.PathUtil.Average(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Finds the average of the points.
            </summary>
            <param name="aPoints">A list of points.</param>
            <returns>Average of all the points.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetInteriorAngle(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Finds the interior angle (degrees) of the corner specified by 'i'. Endpoints on unclosed lines are 180. Path should be counterclockwise.
            </summary>
            <param name="i">Index of the corner to calculate the angle of</param>
            <param name="aPath">The path of points, sorted counterclockwise.</param>
            <param name="aClosed">Is the path closed?</param>
            <returns>The interior angle, in degrees.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetPointNormal(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the normal at the specified path index. Doesn't account for segment lengths.
            </summary>
            <param name="aPath">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to get the normal of.</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetPointNormalWeighted(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the normal at the specified path index, taking into account weighting based on segment length.
            </summary>
            <param name="aPath">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to get the normal of.</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetPointNormal3D(System.Int32,System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            <summary>
            Gets the normal at the specified path index.
            </summary>
            <param name="aPath">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the vertex to get the normal of.</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetPointTangent(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the tangent at the specified path index.
            </summary>
            <param name="aPath">The list of vertices used to calculate the tanget.</param>
            <param name="i">Index of the vertex to get the tangent of.</param>
            <param name="aClosed">Should we interpolate at the edges of the path as though it was closed?</param>
            <returns>A normalized tangent!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetSegmentTangent(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the tangent at the specified segment index.
            </summary>
            <param name="aPath">The list of vertices used to calculate the tanget.</param>
            <param name="i">Index of the segment to get the tangent of.</param>
            <param name="aClosed">Should we check the closing edge, or clamp?</param>
            <returns>A normalized tangent!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetSegmentNormal(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the normal at the specified path segment.
            </summary>
            <param name="aPath">The list of vertices used to calculate the normal.</param>
            <param name="i">Index of the first vert of the segment.</param>
            <param name="aClosed">Should we wrap around as though it was closed?</param>
            <returns>A normalized normal!</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetSegmentLength(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean)">
            <summary>
            Gets the length of the specified path segment.
            </summary>
            <param name="aPath">The list of vertices used to calculate the length.</param>
            <param name="i">Index of the first vert of the segment.</param>
            <param name="aClosed">Should we wrap around as though it was closed?</param>
            <returns>Distance between the indicated vertex and the next one on the path</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetClosestSegment(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2,System.Boolean)">
            <summary>
            Gets the index of the path point that starts the closest line segment to the specified point.
            </summary>
            <param name="aPoint">The point to check from.</param>
            <returns>Index of the first point in the line segment, the other point would be Index+1</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetClosestPoint(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2,System.Int32)">
            <summary>
            Gets the index of the point closest to the specified point, while ignoring a particular index.
            </summary>
            <param name="aPoint">The point to check from.</param>
            <param name="aIgnore">The point to ignore, or -1 for don't ignore any of them</param>
            <returns>Index of the point.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetDistanceFromPath(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2,System.Boolean)">
            <summary>
            Gets the smallest distance to the provided path.
            </summary>
            <param name="aPath">The path you're checking distance against</param>
            <param name="aClosed">Is the path provided closed? Should we check the closing segment too?</param>
            <param name="aPoint">The point to check from.</param>
            <returns>Smallest distance! float.MaxValue if none found</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetDistanceFromPathSq(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2,System.Boolean)">
            <summary>
            Gets the smallest distance^2 to the provided path.
            </summary>
            <param name="aPath">The path you're checking distance against</param>
            <param name="aClosed">Is the path provided closed? Should we check the closing segment too?</param>
            <param name="aPoint">The point to check from.</param>
            <returns>Smallest distance^2! float.MaxValue if none found</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetClosetPointOnLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean)">
            <summary>
            A utility function! Gets the closest point on a line, clamped to the line segment provided.
            </summary>
            <param name="aStart">Start of the line segment.</param>
            <param name="aEnd">End of the line segment.</param>
            <param name="aPoint">The point to compare distance to.</param>
            <param name="aClamp">Should we clamp at the ends of the segment, or treat it as an infinite line?</param>
            <returns>The closest point =D</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetClosetPointOnLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean)">
            <summary>
            A utility function! Gets the closest point on a line, clamped to the line segment provided.
            </summary>
            <param name="aStart">Start of the line segment.</param>
            <param name="aEnd">End of the line segment.</param>
            <param name="aPoint">The point to compare distance to.</param>
            <param name="aClamp">Should we clamp at the ends of the segment, or treat it as an infinite line?</param>
            <returns>The closest point =D</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetDistanceFromLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean)">
            <summary>
            A utility function! Gets the distance from the point to a line, clamped to the line segment provided.
            </summary>
            <param name="aStart">Start of the line segment.</param>
            <param name="aEnd">End of the line segment.</param>
            <param name="aPoint">The point to compare distance to.</param>
            <param name="aClamp">Should we clamp at the ends of the segment, or treat it as an infinite line?</param>
            <returns>Distance from the closest point</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetSqDistanceFromLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean)">
            <summary>
            A utility function! Gets the squared distance from the point to a line, clamped to the line segment provided.
            </summary>
            <param name="aStart">Start of the line segment.</param>
            <param name="aEnd">End of the line segment.</param>
            <param name="aPoint">The point to compare distance to.</param>
            <param name="aClamp">Should we clamp at the ends of the segment, or treat it as an infinite line?</param>
            <returns>Distance squared from the closest point</returns>
        </member>
        <member name="M:Ferr.PathUtil.LineIntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Gets the intersection point of two unbounded lines, returns (0,0) if lines are parallel.
            </summary>
            <param name="aLine1Pt1">A point along the first line.</param>
            <param name="aLine1Pt2">Second point along the first line.</param>
            <param name="aLine2Pt1">A point along the second line.</param>
            <param name="aLine2Pt2">Second point along the second line.</param>
            <returns>Intersection point, or (0,0) if parallel.</returns>
        </member>
        <member name="M:Ferr.PathUtil.LineSegmentIntersection(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Checks if the two bounded line segments intersect.
            </summary>
            <returns>Do they intersect?</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetIntersections(UnityEngine.Vector2,UnityEngine.Vector2,System.Collections.Generic.List{UnityEngine.Vector2},System.Boolean,System.Boolean)">
            <summary>
            Finds all the intersections of a closed line segment with a path.
            </summary>
            <param name="aLineStart">Start of the intersection line.</param>
            <param name="aLineEnd">End of the intersection line.</param>
            <param name="aPath">The path to test for intersections on.</param>
            <param name="aClosed">Is the path closed, should we test the closing segment?</param>
            <param name="aGetPoints">Do we need to calculate the exact intersection points, or is just the segment info enough?</param>
            <returns>A list of intersections. Intersection.segmentIndex is always filled in, Intersection.point is only filled if aGetPoints is true.</returns>
        </member>
        <member name="M:Ferr.PathUtil.GetSegmentsUnder(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2)">
            <summary>
            Gets a list of line segments that are under the given point. Two indices per segment.
            </summary>
            <param name="aPath">A list of path vertices.</param>
            <param name="aPoint">The point.</param>
            <returns></returns>
        </member>
        <member name="M:Ferr.PathUtil.CountSegmentsUnder(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2)">
            <summary>
            Gets the count of line segments that are under the given point.
            </summary>
            <param name="aPath">A list of path vertices.</param>
            <param name="aPoint">The point.</param>
            <returns></returns>
        </member>
        <member name="M:Ferr.PathUtil.IsInPoly(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2)">
            <summary>
            Finds if a point is inside or on a polygon.
            </summary>
            <param name="aPoly">A list of vertices representing a closed polygon.</param>
            <param name="aPoint">The point.</param>
            <returns>True if inside the poly, false if outside.</returns>
        </member>
        <member name="M:Ferr.PathUtil.IsInPoly(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Checks if one closed polygon is inside, outside, or intersecting another closed polygon. No overlap is fast, but overlap invokes an O(n^2) intersection algorithm.
            </summary>
            <param name="aIsPoly">Answer is with respect to this closed polygon.</param>
            <param name="aInPoly">Closed polygon to check against.</param>
            <returns>Is aIsPoly inside, outside, or intersectiong aInPoly?</returns>
        </member>
        <member name="M:Ferr.PathUtil.IndicesToPath(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{System.Int32})">
            <summary>
            Converts a list of path indices to a list of path verts created from the given list.
            </summary>
            <param name="aPath">Path to pull vert data from</param>
            <param name="aIndices">List of inidces to pull from the path.</param>
            <returns>A list of path verts as indicated by the index list</returns>
        </member>
        <member name="P:Ferr2DT_Material.fillMaterial">
            <summary>
            The material of the interior of the terrain.
            </summary>
        </member>
        <member name="P:Ferr2DT_Material.edgeMaterial">
            <summary>
            The material of the edges of the terrain.
            </summary>
        </member>
        <member name="P:Ferr2DT_Material.descriptorCount">
            <summary>
            How many edge descriptors are present in the material?
            </summary>
        </member>
        <member name="P:Ferr2DT_Material.IsPerfect">
            <summary>
            Is this material ok to use for perfect edges?
            </summary>
        </member>
        <member name="M:Ferr2DT_Material.GetDescriptor(Ferr2DT_TerrainDirection)">
            <summary>
            Gets the edge descriptor for the given edge, defaults to the Top, if none by that type exists, or an empty one, if none are defined at all.
            </summary>
            <param name="aDirection">Direction to get.</param>
            <returns>The given direction, or the first direction, or a default, based on what actually exists.</returns>
        </member>
        <member name="M:Ferr2DT_Material.Has(Ferr2DT_TerrainDirection)">
            <summary>
            Finds out if we actually have a descriptor for the given direction
            </summary>
            <param name="aDirection">Duh.</param>
            <returns>is it there, or is it not?</returns>
        </member>
        <member name="M:Ferr2DT_Material.Set(Ferr2DT_TerrainDirection,System.Boolean)">
            <summary>
            Sets a particular direction as having a valid descriptor. Or not. That's a bool.
            </summary>
            <param name="aDirection">The direction!</param>
            <param name="aActive">To active, or not to active? That is the question!</param>
        </member>
        <member name="M:Ferr2DT_Material.ToUV(UnityEngine.Rect)">
            <summary>
            Converts our internal pixel UV coordinates to UV values Unity will recognize.
            </summary>
            <param name="aNativeRect">A UV rect, using pixels.</param>
            <returns>A UV rect using Unity coordinates.</returns>
        </member>
        <member name="M:Ferr2DT_Material.ToScreen(UnityEngine.Rect)">
            <summary>
            Converts our internal pixel UV coordinates to UV values we can use on the screen! As 0-1.
            </summary>
            <param name="aNativeRect">A UV rect, using pixels.</param>
            <returns>A UV rect using standard UV coordinates.</returns>
        </member>
        <member name="T:Ferr2DT_ColorType">
            <summary>
            Describes the way that Ferr2DT assigns vertex colors to the terrain.
            </summary>
        </member>
        <member name="F:Ferr2DT_ColorType.SolidColor">
            <summary>
            Assigns a single color to all verts.
            </summary>
        </member>
        <member name="F:Ferr2DT_ColorType.Gradient">
            <summary>
            Assigns a color gradient across the terrain at a given angle.
            </summary>
        </member>
        <member name="F:Ferr2DT_ColorType.DistanceGradient">
            <summary>
            Assigns a color gradient based on the vertex distance from the edge
            </summary>
        </member>
        <member name="F:Ferr2DT_ColorType.PreserveVertColor">
            <summary>
            Preserves the existing colors as best as possible, for use with vertex painting and stuff like that.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.fillY">
            <summary>
            If fill is set to Skirt, this value represents the Y value of where the skirt will end.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.fillZ">
            <summary>
            In order to combat Z-Fighting, this allows you to set a Z-Offset on the fill.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.invertFillBorder">
            <summary>
            When fill is inverted, how large is the outside border? Zero will auto-size the border.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.splitCorners">
            <summary>
            This will separate edges at corners, for applying different material parts to different slopes,
            as well as creating sharp corners on smoothed paths.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.pixelsPerUnit">
            <summary>
            Roughly how many pixels we try to fit into one unit of Unity space
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertexColorType">
            <summary>
            Describes the way that Ferr2DT assigns vertex colors to the terrain.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertexColor">
            <summary>
            The color for every vertex! If you use the right shader (like the Ferr2D shaders) this will influence
            the color of the terrain. This is faster, because you don't need additional materials for new colors!
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertexGradient">
            <summary>
            A gradient that starts at one end of the terrain, and ends at the other, following the angle provided
            by vertexGradientAngle.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertexGradientAngle">
            <summary>
            Angle at which the gradient travels across the mesh (degrees).
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertexGradientDistance">
            <summary>
            Maximum distance for the gradient when using DistanceGradient vertex color type
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.createTangents">
            <summary>
            Tangents are important for normal mapping! Sadly, it's a tiny bit expensive, so I don't recommend doing it all the time!
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.uvOffset">
            <summary>
            Offset from the global uv coordinates, for fine control over the fill location
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.slantAmount">
            <summary>
            Z offset value for how slanted the edges should be. This can add a nice parallax effect to your terrain.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.fillSplit">
            <summary>
            Adds extra grid spaced verts to the fill mesh for use with vertex lighting or painting.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.fillSplitDistance">
            <summary>
            Distance between vert splits on the fill mesh.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.usedByEffector">
            <summary>
            Indicates the collider will be used by any effectors on this object
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.isTrigger">
            <summary>
            Transfers over into the collider, when it gets generated
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.depth">
            <summary>
            How wide should the collider be on the Z axis? (Unity units)
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.physicsMaterial">
            <summary>
            For terrains that have no edge, use this for physics!
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.physicsMaterial2D">
            <summary>
            For terrains that have no edge, use this for physics!
            </summary>
        </member>
        <member name="P:Ferr2DT_PathTerrain.TerrainMaterial">
            <summary>
            This property will call SetMaterial when set.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ferr2DT_PathTerrain.MeshData" -->
        <!-- Badly formed XML comment ignored for member "P:Ferr2DT_PathTerrain.MeshFilter" -->
        <member name="P:Ferr2DT_PathTerrain.IsLegacy">
            <summary>
            Does this terrain use v1.12 path data or earlier?
            </summary>
        </member>
        <member name="P:Ferr2DT_PathTerrain.CheckedLegacy">
            <summary>
            Allows to see and reset whether we've checked it's a Legacy terrain. Useful for undo, or upgrade functionality.
            </summary>
        </member>
        <member name="M:Ferr2DT_PathTerrain.Build(System.Boolean)">
            <summary>
            This method gets called automatically whenever the Ferr2DT path gets updated in the 
            editor. This will completely recreate the the visual mesh (only) for the terrain. If you want
            To recreate the collider as well, that's a separate call to RecreateCollider.
            </summary>
        </member>
        <member name="M:Ferr2DT_PathTerrain.RecreateCollider">
            <summary>
            Creates a mesh or poly and adds it to the collider object. This is automatically calld on Start,
            if createCollider is set to true. This will automatically add a collider if none is 
            attached already.
            </summary>
        </member>
        <member name="M:Ferr2DT_PathTerrain.SetMaterial(IFerr2DTMaterial)">
            <summary>
            Sets the material of the mesh.
            </summary>
            <param name="aMaterial">The terrain material! Usually from a terrain material asset.</param>
        </member>
        <member name="M:Ferr2DT_PathTerrain.AddPoint(UnityEngine.Vector2,System.Int32,Ferr.PointType)">
            <summary>
            Adds a terrain vertex at the specified index, or at the end if the index is -1. Returns the index of the added vert. Does not rebuild meshes.
            </summary>
            <param name="aPt">The terrain point to add, z is always 0</param>
            <param name="aAtIndex">The index to put the point at, or -1 to put at the end</param>
            <returns>Index of the point</returns>
        </member>
        <member name="M:Ferr2DT_PathTerrain.AddAutoPoint(UnityEngine.Vector2,Ferr.PointType)">
            <summary>
            Inserts a point into the path, automatically determining insert index using Ferr2DT_Path.GetClosestSeg. Does not rebuild meshes.
            </summary>
            <returns>The index of the point that was just added.</returns>
            <param name="aPt">A 2D point to add to the path.</param>
        </member>
        <member name="M:Ferr2DT_PathTerrain.RemovePoint(System.Int32)">
            <summary>
            Removes the indicated point as well as corresponding data. Does not rebuild meshes.
            </summary>
            <param name="aPtIndex">Index of the point</param>
        </member>
        <member name="M:Ferr2DT_PathTerrain.ClearPoints">
            <summary>
            Removes all points from the terrain properly. Does not rebuild meshes.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.smoothPath">
            <summary>
            [Legacy] Makes the path curvy. It's not a perfect algorithm just yet, but it does make things curvier.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.splitCount">
            <summary>
            [Legacy] On smoothed surfaces, the distance between each split on the curve (Unity units)
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.splitDist">
            <summary>
            [Legacy] A modifier that allows you to specify a multiplier for many cuts go into the fill/collider relative to the initial value
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.splitMiddle">
            <summary>
            [Legacy] Split the edges in half, lengthwise. This doubles tri count along edges, but can improve texture stretching along corners
            or turns
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.randomByWorldCoordinates">
            <summary>
            [Legacy] Randomizes edge pieces based on its individual location, rather than by the location of the segment. This is great for
            terrain that might get procedurally modified in such a way that all segments get shuffled.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.createCollider">
            <summary>
            [Legacy] Should we generate a collider on Start?
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.create3DCollider">
            <summary>
            [Legacy] Use this to force a 3D mesh collider instead of a 2D collider
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.sharpCorners">
            <summary>
            [Legacy] Generates colliders with sharp angles at the corners. Edges are extended by the cap size, and cut off at the intersection point.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.sharpCornerDistance">
            <summary>
            [Legacy] How far should the collider edges be extended to create a sharp corner?
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.smoothSphereCollisions">
            <summary>
            [Legacy] An option to pass along for 3D colliders
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.surfaceOffset">
            <summary>
            [Legacy] For offseting the collider, so it can line up with stuff better visually. On fill = None terrain,
            this behaves significantly different than regular closed terrain.
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.useEdgeCollider">
            <summary>
            [Legacy]Use a 2D edge collider instead of a polygon collider
            </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.colliderThickness">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.collidersLeft">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.collidersRight">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.collidersTop">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.collidersBottom">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.directionOverrides">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.cutOverrides">
            <summary> [Legacy] </summary>
        </member>
        <member name="F:Ferr2DT_PathTerrain.vertScales">
            <summary> [Legacy] </summary>
        </member>
        <member name="P:Ferr2DT_PathTerrain.Path">
            <summary>
            [Legacy]
            </summary>
        </member>
        <member name="M:Ferr2DT_PathTerrain.LegacyGetColliderVerts">
            <summary>
            Retrieves a list of line segments that directly represent the collision volume of the terrain. This includes offsets and removed edges.
            </summary>
            <returns>A list of line segments.</returns>
        </member>
        <member name="M:Ferr2DT_PathTerrain.MatchOverrides">
            <summary>
            [Legacy] This method ensures that path overrides are properly present. Adds them if there aren't enough, and removes them if there are too many.
            </summary>
        </member>
        <member name="M:Ferr2DT_PathTerrain.ForceMaterial(IFerr2DTMaterial,System.Boolean,System.Boolean)">
            <summary>
            [Legacy] This will allow you to set the terrain material regardless of whether it's marked as the current material already or not. Also calls RecreatePath when finished.
            </summary>
            <param name="aMaterial">The terrain material! Usually from a terrain material prefab.</param>
            <param name="aForceUpdate">Force it to set the material, even if it's already the set material, or no?</param>
            <param name="aRecreate">Should we recreate the mesh? Usually, this is what you want (only happens if the material changes, or is forced to change)</param>
        </member>
        <member name="T:Ferr2DT_FillMode">
            <summary>
            Describes how the terrain path should be filled.
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.Closed">
            <summary>
            The interior of the path will be filled, and edges will be treated like a polygon.
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.Skirt">
            <summary>
            Drops some extra vertices down, and fill the interior. Edges only around the path itself.
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.None">
            <summary>
            Doesn't fill the interior at all. Just edges.
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.InvertedClosed">
            <summary>
            Fills the outside of the path rather than the interior, also inverts the edges, upside-down.
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.FillOnlyClosed">
            <summary>
            Just like Closed, but with no edges
            </summary>
        </member>
        <member name="F:Ferr2DT_FillMode.FillOnlySkirt">
            <summary>
            Just like Skirt, but with no edges
            </summary>
        </member>
        <member name="T:Ferr2DT_SegmentDescription">
            <summary>
            Describes a terrain segment, and how it should be drawn.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.ApplyTo">
            <summary> Applies only to terrain segments facing this direction. </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.ZOffset">
            <summary> Z Offset, for counteracting depth issues. </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.YOffset">
            <summary> [Legacy, use YOffsetPercent] Just in case you want to adjust the height of the segment </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.YOffsetPercent">
            <summary> Just in case you want to adjust the height of the segment </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.CapOffset">
            <summary> [Legacy] How much should the end of the path slide to make room for the caps? (Unity units) </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.applyTo">
            <summary>
            [Legacy] Applies only to terrain segments facing this direction.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.zOffset">
            <summary>
            [Legacy] Z Offset, for counteracting depth issues.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.yOffset">
            <summary>
            [Legacy] Just in case you want to adjust the height of the segment
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.capOffset">
            <summary>
            [Legacy] How much should the end of the path slide to make room for the caps? (Unity units)
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.leftCap">
            <summary>
            [Legacy] UV coordinates for the left ending cap.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.innerLeftCap">
            <summary>
            [Legacy] UV coordinates for the left ending cap.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.rightCap">
            <summary>
            [Legacy] UV coordinates for the right ending cap.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.innerRightCap">
            <summary>
            [Legacy] UV coordinates for the right ending cap.
            </summary>
        </member>
        <member name="P:Ferr2DT_SegmentDescription.body">
            <summary>
            [Legacy] A list of body UVs to randomly pick from.
            </summary>
        </member>
        <member name="T:Ferr2DT_TerrainMaterial">
            <summary>
            Describes a material that can be applied to a Ferr2DT_PathTerrain
            </summary>
        </member>
        <member name="P:Ferr2DT_TerrainMaterial.fillMaterial">
            <summary>
            The material of the interior of the terrain.
            </summary>
        </member>
        <member name="P:Ferr2DT_TerrainMaterial.edgeMaterial">
            <summary>
            The material of the edges of the terrain.
            </summary>
        </member>
        <member name="P:Ferr2DT_TerrainMaterial.descriptorCount">
            <summary>
            How many edge descriptors are present in the material?
            </summary>
        </member>
        <member name="M:Ferr2DT_TerrainMaterial.GetDescriptor(Ferr2DT_TerrainDirection)">
            <summary>
            Gets the edge descriptor for the given edge, defaults to the Top, if none by that type exists, or an empty one, if none are defined at all.
            </summary>
            <param name="aDirection">Direction to get.</param>
            <returns>The given direction, or the first direction, or a default, based on what actually exists.</returns>
        </member>
        <member name="M:Ferr2DT_TerrainMaterial.Has(Ferr2DT_TerrainDirection)">
            <summary>
            Finds out if we actually have a descriptor for the given direction
            </summary>
            <param name="aDirection">Duh.</param>
            <returns>is it there, or is it not?</returns>
        </member>
        <member name="M:Ferr2DT_TerrainMaterial.Set(Ferr2DT_TerrainDirection,System.Boolean)">
            <summary>
            Sets a particular direction as having a valid descriptor. Or not. That's a bool.
            </summary>
            <param name="aDirection">The direction!</param>
            <param name="aActive">To active, or not to active? That is the question!</param>
        </member>
        <member name="M:Ferr2DT_TerrainMaterial.ToUV(UnityEngine.Rect)">
            <summary>
            Converts our internal pixel UV coordinates to UV values Unity will recognize.
            </summary>
            <param name="aNativeRect">A UV rect, using pixels.</param>
            <returns>A UV rect using Unity coordinates.</returns>
        </member>
        <member name="M:Ferr2DT_TerrainMaterial.ToScreen(UnityEngine.Rect)">
            <summary>
            Converts our internal pixel UV coordinates to UV values we can use on the screen! As 0-1.
            </summary>
            <param name="aNativeRect">A UV rect, using pixels.</param>
            <returns>A UV rect using standard UV coordinates.</returns>
        </member>
        <member name="T:Ferr2DT_TerrainDirection">
            <summary>
            A direction used to describe the surface of terrain.
            </summary>
        </member>
        <member name="M:Rewired.Demos.CustomControllersTiltDemo.OnInputUpdate">
            <summary>
            This will be called each time input updates. Use this to push values into the Custom Controller axes.
            </summary>
        </member>
        <member name="F:Rewired.UI.ControlMapper.CalibrationWindow.minSensitivity">
            <summary>
            This value prevents the user from lowering the axis sensitivity so far that the axis is unusable.
            This is very important for the axes used for menu navigation, otherwise the user could permanently
            disable their ability to navigate the menu on a console with no mouse/keyboard.
            This value will be drawn from the InputBehavior(s) assigned to the menu horizontal and vertical axes
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.CanvasScalerExt">
            <summary>
            This class exists only for the purpose of being able to force a refresh on the canvas scaler to prevent drawing artifacts when changing the scale on Awake/Enable
            </summary>
        </member>
        <member name="M:Rewired.UI.ControlMapper.CanvasScalerExt.ForceRefresh">
            <summary>
            Force a refresh on the canvas scaler.
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.CanvasScalerFitter">
            <summary>
            Adjusts the scale based on the current screen aspect ratio to try to fit the content sensibly.
            Uses break points to determine current scale settings.
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.CustomButton">
            <summary>
            Overrides auto-navigation in Selectable because it's inadequate for selectables inside a scroll rect
            Also enables selection of disabled controls for better navigation experience.
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.CustomSlider">
            <summary>
            Overrides auto-navigation in Selectable because it's inadequate for selectables inside a scroll rect
            Also enables selection of disabled controls for better navigation experience.
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.CustomToggle">
            <summary>
            Overrides auto-navigation in Selectable because it's inadequate for selectables inside a scroll rect
            Also enables selection of disabled controls for better navigation experience.
            </summary>
        </member>
        <member name="T:Rewired.UI.ControlMapper.ScrollbarVisibilityHelper">
            <summary>
            Hides ScrollRect scrollbars based on the dimensions of the content.
            This must be placed on the ScrollRect.content GameObject.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.useAllRewiredGamePlayers">
            <summary>
            Allow all Rewired game Players to control the UI. This does not include the System Player. If enabled, this setting overrides individual Player Ids set in Rewired Player Ids.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.useRewiredSystemPlayer">
            <summary>
            Allow the Rewired System Player to control the UI.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.rewiredPlayerIds">
            <summary>
            A list of Player Ids that are allowed to control the UI. If Use All Rewired Game Players = True, this list will be ignored.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.usePlayingPlayersOnly">
            <summary>
            Allow only Players with Player.isPlaying = true to control the UI.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.moveOneElementPerAxisPress">
            <summary>
            Makes an axis press always move only one UI selection. Enable if you do not want to allow scrolling through UI elements by holding an axis direction.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.UseAllRewiredGamePlayers">
            <summary>
            Allow all Rewired game Players to control the UI. This does not include the System Player. If enabled, this setting overrides individual Player Ids set in Rewired Player Ids.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.UseRewiredSystemPlayer">
            <summary>
            Allow the Rewired System Player to control the UI.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.RewiredPlayerIds">
            <summary>
            A list of Player Ids that are allowed to control the UI. If Use All Rewired Game Players = True, this list will be ignored.
            Returns a clone of the array.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.UsePlayingPlayersOnly">
            <summary>
            Allow only Players with Player.isPlaying = true to control the UI.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.MoveOneElementPerAxisPress">
            <summary>
            Makes an axis press always move only one UI selection. Enable if you do not want to allow scrolling through UI elements by holding an axis direction.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.allowMouseInput">
            <summary>
            Allows the mouse to be used to select elements.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.allowMouseInputIfTouchSupported">
            <summary>
            Allows the mouse to be used to select elements if the device also supports touch control.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_VerticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_SubmitButton">
            <summary>
            Name of the action used to submit.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_CancelButton">
            <summary>
            Name of the action used to cancel.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_InputActionsPerSecond">
            <summary>
            Number of selection changes allowed per second when a movement button/axis is held in a direction.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_RepeatDelay">
            <summary>
            Delay in seconds before vertical/horizontal movement starts repeating continouously when a movement direction is held.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_allowMouseInput">
            <summary>
            Allows the mouse to be used to select elements.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_allowMouseInputIfTouchSupported">
            <summary>
            Allows the mouse to be used to select elements if the device also supports touch control.
            </summary>
        </member>
        <member name="F:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.m_ForceModuleActive">
            <summary>
            Forces the module to always be active.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.allowActivationOnMobileDevice">
            <summary>
            Allows the module to control UI input on mobile devices..
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.forceModuleActive">
            <summary>
            Forces the module to always be active.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.inputActionsPerSecond" -->
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.repeatDelay">
            <summary>
            Delay in seconds before vertical/horizontal movement starts repeating continouously when a movement direction is held.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.horizontalAxis">
            <summary>
            Name of the horizontal axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.verticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.submitButton">
            <summary>
            Name of the action used to submit.
            </summary>
        </member>
        <member name="P:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.cancelButton">
            <summary>
            Name of the action used to cancel.
            </summary>
        </member>
        <member name="M:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.SendSubmitEventToSelectedObject">
            <summary>
            Process submit keys.
            </summary>
        </member>
        <member name="M:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.SendMoveEventToSelectedObject">
            <summary>
            Process keyboard events.
            </summary>
        </member>
        <member name="M:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.ProcessMouseEvent(System.Int32)">
            <summary>
            Process all mouse events.
            </summary>
        </member>
        <member name="M:Rewired.Integration.UnityUI.RewiredStandaloneInputModule.ProcessMousePress(UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData)">
            <summary>
            Process the current mouse press.
            </summary>
        </member>
        <member name="T:Rewired.Data.UserDataStore_PlayerPrefs">
            <summary>
            Class for saving data to PlayerPrefs. Add this as a component to your Rewired Input Manager to save and load data automatically to PlayerPrefs.
            Copy this class and customize it to your needs to create a new custom data storage system.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.Save">
            <summary>
            Save all data now.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.SaveControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.SaveControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller. Does not save Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.SavePlayerData(System.Int32)">
            <summary>
            Save all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.SaveInputBehavior(System.Int32,System.Int32)">
            <summary>
            Save all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.Load">
            <summary>
            Load all data now.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.LoadControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.LoadControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller. Does not load Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.LoadPlayerData(System.Int32)">
            <summary>
            Load all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.LoadInputBehavior(System.Int32,System.Int32)">
            <summary>
            Load all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.OnInitialize">
            <summary>
            Called when SaveDataStore is initialized.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.OnControllerConnected(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Called when a controller is connected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.OnControllerPreDiscconnect(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Calls after a controller has been disconnected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore_PlayerPrefs.OnControllerDisconnected(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Called when a controller is about to be disconnected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="T:Rewired.Utils.ExternalTools">
            <exclude></exclude>
        </member>
        <member name="M:Spine.Animation.Apply(Spine.Skeleton,System.Single,System.Single,System.Boolean,Spine.ExposedList{Spine.Event},System.Single,Spine.MixPose,Spine.MixDirection)">
            <summary>Applies all the animation's timelines to the specified skeleton.</summary>
            <seealso cref="!:Timeline.Apply(Skeleton, float, float, ExposedList, float, MixPose, MixDirection)"/>
        </member>
        <member name="M:Spine.Animation.BinarySearch(System.Single[],System.Single,System.Int32)">
            <param name="target">After the first and before the last entry.</param>
        </member>
        <member name="M:Spine.Animation.BinarySearch(System.Single[],System.Single)">
            <param name="target">After the first and before the last entry.</param>
        </member>
        <member name="M:Spine.Timeline.Apply(Spine.Skeleton,System.Single,System.Single,Spine.ExposedList{Spine.Event},System.Single,Spine.MixPose,Spine.MixDirection)">
            <summary>Sets the value(s) for the specified time.</summary>
            <param name="skeleton">The skeleton the timeline is being applied to. This provides access to the bones, slots, and other skeleton components the timeline may change.</param>
            <param name="lastTime">lastTime The time this timeline was last applied. Timelines such as EventTimeline trigger only at specific times rather than every frame. In that case, the timeline triggers everything between lastTime (exclusive) and <code>time</code> (inclusive).</param>
            <param name="time">The time within the animation. Most timelines find the key before and the key after this time so they can interpolate between the keys.</param>
            <param name="events">If any events are fired, they are added to this list. Can be null to ignore firing events or if the timeline does not fire events. May be null.</param>
            <param name="alpha">alpha 0 applies the current or setup pose value (depending on pose parameter). 1 applies the timeline 
            	value. Between 0 and 1 applies a value between the current or setup pose and the timeline value. By adjusting
            	alpha over time, an animation can be mixed in or out. <code>alpha</code> can also be useful to
            	 apply animations on top of each other (layered).</param>
            <param name="pose">Controls how mixing is applied when alpha is than 1.</param>
            <param name="direction">Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions such as DrawOrderTimeline and AttachmentTimeline.</param>
        </member>
        <member name="T:Spine.MixPose">
            <summary>
            Controls how a timeline is mixed with the setup or current pose.</summary>
            <seealso cref="!:Timeline.Apply(Skeleton, float, float, ExposedList, float, MixPose, MixDirection)"/>
        </member>
        <member name="F:Spine.MixPose.Setup">
            <summary> The timeline value is mixed with the setup pose (the current pose is not used).</summary>
        </member>
        <member name="F:Spine.MixPose.Current">
            <summary> The timeline value is mixed with the current pose. The setup pose is used as the timeline value before the first key,
            except for timelines which perform instant transitions, such as DrawOrderTimeline or AttachmentTimeline.</summary>
        </member>
        <member name="F:Spine.MixPose.CurrentLayered">
            <summary> The timeline value is mixed with the current pose. No change is made before the first key (the current pose is kept until the first key).</summary>
        </member>
        <member name="T:Spine.MixDirection">
            <summary>
            Indicates whether a timeline's <code>alpha</code> is mixing out over time toward 0 (the setup or current pose) or mixing in toward 1 (the timeline's pose).</summary>
            <seealso cref="!:Timeline.Apply(Skeleton, float, float, ExposedList, float, MixPose, MixDirection)"/>
        </member>
        <member name="T:Spine.CurveTimeline">
            <summary>Base class for frames that use an interpolation bezier curve.</summary>
        </member>
        <member name="M:Spine.CurveTimeline.SetCurve(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
            cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
            the difference between the keyframe's values.</summary>
        </member>
        <member name="M:Spine.RotateTimeline.SetFrame(System.Int32,System.Single,System.Single)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.TranslateTimeline.SetFrame(System.Int32,System.Single,System.Single,System.Single)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.ColorTimeline.SetFrame(System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.TwoColorTimeline.SetFrame(System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.AttachmentTimeline.SetFrame(System.Int32,System.Single,System.String)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.DeformTimeline.SetFrame(System.Int32,System.Single,System.Single[])">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.EventTimeline.SetFrame(System.Int32,Spine.Event)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.EventTimeline.Apply(Spine.Skeleton,System.Single,System.Single,Spine.ExposedList{Spine.Event},System.Single,Spine.MixPose,Spine.MixDirection)">
            <summary>Fires events for frames &gt; lastTime and &lt;= time.</summary>
        </member>
        <member name="M:Spine.DrawOrderTimeline.SetFrame(System.Int32,System.Single,System.Int32[])">
            <summary>Sets the time and value of the specified keyframe.</summary>
            <param name="drawOrder">May be null to use bind pose draw order.</param>
        </member>
        <member name="M:Spine.IkConstraintTimeline.SetFrame(System.Int32,System.Single,System.Single,System.Int32)">
            <summary>Sets the time, mix and bend direction of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.PathConstraintPositionTimeline.SetFrame(System.Int32,System.Single,System.Single)">
            <summary>Sets the time and value of the specified keyframe.</summary>
        </member>
        <member name="M:Spine.PathConstraintMixTimeline.SetFrame(System.Int32,System.Single,System.Single,System.Single)">
            <summary>Sets the time and mixes of the specified keyframe.</summary>
        </member>
        <member name="P:Spine.AnimationState.Tracks">
            <summary>A list of tracks that have animations, which may contain nulls.</summary>
        </member>
        <member name="M:Spine.AnimationState.Update(System.Single)">
            <summary>
            Increments the track entry times, setting queued animations as current if needed</summary>
            <param name="delta">delta time</param>
        </member>
        <member name="M:Spine.AnimationState.UpdateMixingFrom(Spine.TrackEntry,System.Single)">
            <summary>Returns true when all mixing from entries are complete.</summary>
        </member>
        <member name="M:Spine.AnimationState.Apply(Spine.Skeleton)">
            <summary>
            Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the 
            animation state can be applied to multiple skeletons to pose them identically.</summary>
        </member>
        <member name="M:Spine.AnimationState.ClearTracks">
            <summary>
            Removes all animations from all tracks, leaving skeletons in their previous pose. 
            It may be desired to use <see cref="M:Spine.AnimationState.SetEmptyAnimations(System.Single)"/> to mix the skeletons back to the setup pose, 
            rather than leaving them in their previous pose.</summary>
        </member>
        <member name="M:Spine.AnimationState.ClearTrack(System.Int32)">
            <summary>
            Removes all animations from the tracks, leaving skeletons in their previous pose. 
            It may be desired to use <see cref="M:Spine.AnimationState.SetEmptyAnimations(System.Single)"/> to mix the skeletons back to the setup pose, 
            rather than leaving them in their previous pose.</summary>
        </member>
        <member name="M:Spine.AnimationState.SetCurrent(System.Int32,Spine.TrackEntry,System.Boolean)">
            <summary>Sets the active TrackEntry for a given track number.</summary>
        </member>
        <member name="M:Spine.AnimationState.SetAnimation(System.Int32,System.String,System.Boolean)">
            <summary>Sets an animation by name. <seealso cref="M:Spine.AnimationState.SetAnimation(System.Int32,Spine.Animation,System.Boolean)" /></summary>
        </member>
        <member name="M:Spine.AnimationState.SetAnimation(System.Int32,Spine.Animation,System.Boolean)">
            <summary>Sets the current animation for a track, discarding any queued animations.</summary>
            <param name="loop">If true, the animation will repeat.
            If false, it will not, instead its last frame is applied if played beyond its duration.
            In either case <see cref="P:Spine.TrackEntry.TrackEnd"/> determines when the track is cleared. </param>
            <returns>
            A track entry to allow further customization of animation playback. References to the track entry must not be kept 
            after <see cref="E:Spine.AnimationState.Dispose"/>.</returns>
        </member>
        <member name="M:Spine.AnimationState.AddAnimation(System.Int32,System.String,System.Boolean,System.Single)">
            <summary>Queues an animation by name.</summary>
            <seealso cref="M:Spine.AnimationState.AddAnimation(System.Int32,Spine.Animation,System.Boolean,System.Single)" />
        </member>
        <member name="M:Spine.AnimationState.AddAnimation(System.Int32,Spine.Animation,System.Boolean,System.Single)">
            <summary>Adds an animation to be played delay seconds after the current or last queued animation
            for a track. If the track is empty, it is equivalent to calling <see cref="M:Spine.AnimationState.SetAnimation(System.Int32,System.String,System.Boolean)"/>.</summary>
            <param name="delay">
            Seconds to begin this animation after the start of the previous animation. May be &lt;= 0 to use the animation
            duration of the previous track minus any mix duration plus the negative delay.
            </param>
            <returns>A track entry to allow further customization of animation playback. References to the track entry must not be kept 
            after <see cref="E:Spine.AnimationState.Dispose"/></returns>
        </member>
        <member name="M:Spine.AnimationState.SetEmptyAnimation(System.Int32,System.Single)">
            <summary>
            Sets an empty animation for a track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
        </member>
        <member name="M:Spine.AnimationState.AddEmptyAnimation(System.Int32,System.Single,System.Single)">
            <summary>
            Adds an empty animation to be played after the current or last queued animation for a track, and mixes to it over the 
            specified mix duration.</summary>
            <returns>
            A track entry to allow further customization of animation playback. References to the track entry must not be kept after <see cref="E:Spine.AnimationState.Dispose"/>.
            </returns>
            <param name="trackIndex">Track number.</param>
            <param name="mixDuration">Mix duration.</param>
            <param name="delay">Seconds to begin this animation after the start of the previous animation. May be &lt;= 0 to use the animation 
            duration of the previous track minus any mix duration plus the negative delay.</param>
        </member>
        <member name="M:Spine.AnimationState.SetEmptyAnimations(System.Single)">
            <summary>
            Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix duration.</summary>
        </member>
        <member name="M:Spine.AnimationState.NewTrackEntry(System.Int32,Spine.Animation,System.Boolean,Spine.TrackEntry)">
            <summary>Object-pooling version of new TrackEntry. Obtain an unused TrackEntry from the pool and clear/initialize its values.</summary>
            <param name="last">May be null.</param>
        </member>
        <member name="M:Spine.AnimationState.DisposeNext(Spine.TrackEntry)">
            <summary>Dispose all track entries queued after the given TrackEntry.</summary>
        </member>
        <member name="M:Spine.AnimationState.GetCurrent(System.Int32)">
            <returns>The track entry for the animation currently playing on the track, or null if no animation is currently playing.</returns>
        </member>
        <member name="T:Spine.TrackEntry">
            <summary>State for the playback of an animation.</summary>
        </member>
        <member name="M:Spine.TrackEntry.SetTimelineData(Spine.TrackEntry,Spine.ExposedList{Spine.TrackEntry},System.Collections.Generic.HashSet{System.Int32})">
            <summary>Sets the timeline data.</summary>
            <param name="to">May be null.</param>
        </member>
        <member name="P:Spine.TrackEntry.TrackIndex">
            <summary>The index of the track where this entry is either current or queued.</summary>
        </member>
        <member name="P:Spine.TrackEntry.Animation">
            <summary>The animation to apply for this track entry.</summary>
        </member>
        <member name="P:Spine.TrackEntry.Loop">
            <summary>
            If true, the animation will repeat. If false, it will not, instead its last frame is applied if played beyond its duration.</summary>
        </member>
        <member name="P:Spine.TrackEntry.Delay">
            <summary>
             Seconds to postpone playing the animation. When a track entry is the current track entry, delay postpones incrementing 
             the track time. When a track entry is queued, delay is the time from the start of the previous animation to when the 
             track entry will become the current track entry.</summary>
        </member>
        <member name="P:Spine.TrackEntry.TrackTime">
            <summary>
            Current time in seconds this track entry has been the current track entry. The track time determines 
            <see cref="P:Spine.TrackEntry.AnimationTime"/>. The track time can be set to start the animation at a time other than 0, without affecting looping.</summary>
        </member>
        <member name="P:Spine.TrackEntry.TrackEnd">
            <summary>
            The track time in seconds when this animation will be removed from the track. Defaults to the animation duration for 
            non-looping animations and to <see cref="F:System.Int32.MaxValue"/> for looping animations. If the track end time is reached and no 
            other animations are queued for playback, and mixing from any previous animations is complete, properties keyed by the animation, 
            are set to the setup pose and the track is cleared.
            
            It may be desired to use <see cref="M:Spine.AnimationState.AddEmptyAnimation(System.Int32,System.Single,System.Single)"/> to mix the properties back to the 
            setup pose over time, rather than have it happen instantly.
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.AnimationStart">
            <summary>
            Seconds when this animation starts, both initially and after looping. Defaults to 0.
            
            When changing the animation start time, it often makes sense to set <see cref="P:Spine.TrackEntry.AnimationLast"/> to the same value to 
            prevent timeline keys before the start time from triggering.
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.AnimationEnd">
            <summary>
            Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will 
            loop back to <see cref="P:Spine.TrackEntry.AnimationStart"/> at this time. Defaults to the animation duration.</summary>
        </member>
        <member name="P:Spine.TrackEntry.AnimationLast">
            <summary>
            The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
            animation is applied, event timelines will fire all events between the animation last time (exclusive) and animation time 
            (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation is applied.</summary>
        </member>
        <member name="P:Spine.TrackEntry.AnimationTime">
            <summary>
            Uses <see cref="P:Spine.TrackEntry.TrackTime"/> to compute the animation time between <see cref="P:Spine.TrackEntry.AnimationStart"/>. and
            <see cref="P:Spine.TrackEntry.AnimationEnd"/>. When the track time is 0, the animation time is equal to the animation start time.
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.TimeScale">
            <summary>
            Multiplier for the delta time when the animation state is updated, causing time for this animation to play slower or 
            faster. Defaults to 1.
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.Alpha">
            <summary>
            Values less than 1 mix this animation with the last skeleton pose. Defaults to 1, which overwrites the last skeleton pose with 
            this animation.
            
            Typically track 0 is used to completely pose the skeleton, then alpha can be used on higher tracks. It doesn't make sense 
            to use alpha on track 0 if the skeleton pose is from the last frame render. 
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.EventThreshold">
            <summary>
            When the mix percentage (mix time / mix duration) is less than the event threshold, event timelines for the animation 
            being mixed out will be applied. Defaults to 0, so event timelines are not applied for an animation being mixed out.</summary>
        </member>
        <member name="P:Spine.TrackEntry.AttachmentThreshold">
            <summary>
            When the mix percentage (mix time / mix duration) is less than the attachment threshold, attachment timelines for the 
            animation being mixed out will be applied. Defaults to 0, so attachment timelines are not applied for an animation being 
            mixed out.</summary>
        </member>
        <member name="P:Spine.TrackEntry.DrawOrderThreshold">
            <summary>
            When the mix percentage (mix time / mix duration) is less than the draw order threshold, draw order timelines for the 
            animation being mixed out will be applied. Defaults to 0, so draw order timelines are not applied for an animation being 
            mixed out.
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.Next">
            <summary>
            The animation queued to start after this animation, or null.</summary>
        </member>
        <member name="P:Spine.TrackEntry.IsComplete">
            <summary>
            Returns true if at least one loop has been completed.</summary>
        </member>
        <member name="P:Spine.TrackEntry.MixTime">
            <summary>
            Seconds from 0 to the mix duration when mixing from the previous animation to this animation. May be slightly more than 
            <see cref="P:Spine.TrackEntry.MixDuration"/> when the mix is complete.</summary>
        </member>
        <member name="P:Spine.TrackEntry.MixDuration">
            <summary>
            Seconds for mixing from the previous animation to this animation. Defaults to the value provided by 
            <see cref="T:Spine.AnimationStateData"/> based on the animation before this animation (if any).
            
            The mix duration can be set manually rather than use the value from AnimationStateData.GetMix.
            In that case, the mixDuration must be set before <see cref="M:Spine.AnimationState.Update(System.Single)"/> is next called.
            <para>
            When using <seealso cref="M:Spine.AnimationState.AddAnimation(System.Int32,Spine.Animation,System.Boolean,System.Single)"/> with a 
            <code>delay</code> less than or equal to 0, note the <seealso cref="P:Spine.TrackEntry.Delay"/> is set using the mix duration from the <see cref="T:Spine.AnimationStateData"/>
            </para>
            
            </summary>
        </member>
        <member name="P:Spine.TrackEntry.MixingFrom">
            <summary>
            The track entry for the previous animation when mixing from the previous animation to this animation, or null if no 
            mixing is currently occuring. When mixing from multiple animations, MixingFrom makes up a linked list.</summary>
        </member>
        <member name="M:Spine.TrackEntry.ResetRotationDirections">
            <summary>
            Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the 
            long way around when using <see cref="F:Spine.TrackEntry.alpha"/> and starting animations on other tracks. 
            
            Mixing involves finding a rotation between two others, which has two possible solutions: the short way or the long way around. 
            The two rotations likely change over time, so which direction is the short or long way also changes. 
            If the short way was always chosen, bones would flip to the other side when that direction became the long way.
            TrackEntry chooses the short way the first time it is applied and remembers that direction.</summary>
        </member>
        <member name="M:Spine.EventQueue.Drain">
            <summary>Raises all events in the queue and drains the queue.</summary>
        </member>
        <member name="T:Spine.AnimationStateData">
            <summary>Stores mix (crossfade) durations to be applied when AnimationState animations are changed.</summary>
        </member>
        <member name="P:Spine.AnimationStateData.SkeletonData">
            <summary>The SkeletonData to look up animations when they are specified by name.</summary>
        </member>
        <member name="P:Spine.AnimationStateData.DefaultMix">
            <summary>
            The mix duration to use when no mix duration has been specifically defined between two animations.</summary>
        </member>
        <member name="M:Spine.AnimationStateData.SetMix(System.String,System.String,System.Single)">
            <summary>Sets a mix duration by animation names.</summary>
        </member>
        <member name="M:Spine.AnimationStateData.SetMix(Spine.Animation,Spine.Animation,System.Single)">
            <summary>Sets a mix duration when changing from the specified animation to the other. 
            See TrackEntry.MixDuration.</summary>
        </member>
        <member name="M:Spine.AnimationStateData.GetMix(Spine.Animation,Spine.Animation)">
            <summary>
            The mix duration to use when changing from the specified animation to the other, 
            or the DefaultMix if no mix duration has been set.
            </summary>
        </member>
        <member name="M:Spine.Atlas.ReadTuple(System.IO.TextReader,System.String[])">
            <summary>Returns the number of tuple values read (1, 2 or 4).</summary>
        </member>
        <member name="M:Spine.Atlas.FindRegion(System.String)">
            <summary>Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
            should be cached rather than calling this method multiple times.</summary>
            <returns>The region, or null.</returns>
        </member>
        <member name="T:Spine.AtlasAttachmentLoader">
            <summary>
            An AttachmentLoader that configures attachments using texture regions from an Atlas.
            See <a href='http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data'>Loading Skeleton Data</a> in the Spine Runtimes Guide.
            </summary>
        </member>
        <member name="M:Spine.AttachmentLoader.NewRegionAttachment(Spine.Skin,System.String,System.String)">
            <return>May be null to not load any attachment.</return>
        </member>
        <member name="M:Spine.AttachmentLoader.NewMeshAttachment(Spine.Skin,System.String,System.String)">
            <return>May be null to not load any attachment.</return>
        </member>
        <member name="M:Spine.AttachmentLoader.NewBoundingBoxAttachment(Spine.Skin,System.String)">
            <return>May be null to not load any attachment.</return>
        </member>
        <member name="M:Spine.AttachmentLoader.NewPathAttachment(Spine.Skin,System.String)">
            <returns>May be null to not load any attachment</returns>
        </member>
        <member name="T:Spine.BoundingBoxAttachment">
            <summary>Attachment that has a polygon for bounds checking.</summary>
        </member>
        <member name="T:Spine.MeshAttachment">
            <summary>Attachment that displays a texture region using a mesh.</summary>
        </member>
        <member name="P:Spine.MeshAttachment.UVs">
            <summary>The UV pair for each vertex, normalized within the entire texture. <seealso cref="M:Spine.MeshAttachment.UpdateUVs"/></summary>
        </member>
        <member name="P:Spine.PathAttachment.Lengths">
            <summary>The length in the setup pose from the start of the path to the end of each curve.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Spine.PointAttachment" -->
        <member name="T:Spine.RegionAttachment">
            <summary>Attachment that displays a texture region.</summary>
        </member>
        <member name="M:Spine.RegionAttachment.ComputeWorldVertices(Spine.Bone,System.Single[],System.Int32,System.Int32)">
            <summary>Transforms the attachment's four vertices to world coordinates.</summary>
            <param name="bone">The parent bone.</param>
            <param name="worldVertices">The output world vertices. Must have a length greater than or equal to offset + 8.</param>
            <param name="offset">The worldVertices index to begin writing values.</param>
            <param name="stride">The number of worldVertices entries between the value pairs written.</param>
        </member>
        <member name="T:Spine.VertexAttachment">
            <summary>>An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's vertices.</summary> 
        </member>
        <member name="P:Spine.VertexAttachment.Id">
            <summary>Gets a unique ID for this attachment.</summary>
        </member>
        <member name="M:Spine.VertexAttachment.ComputeWorldVertices(Spine.Slot,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32)">
            <summary>Transforms local vertices to world coordinates.</summary>
            <param name="start">The index of the first <see cref="P:Spine.VertexAttachment.Vertices"/> value to transform. Each vertex has 2 values, x and y.</param>
            <param name="count">The number of world vertex values to output. Must be less than or equal to <see cref="P:Spine.VertexAttachment.WorldVerticesLength"/> - start.</param>
            <param name="worldVertices">The output world vertices. Must have a length greater than or equal to <paramref name="offset"/> + <paramref name="count"/>.</param>
            <param name="offset">The <paramref name="worldVertices"/> index to begin writing values.</param>
            <param name="stride">The number of <paramref name="worldVertices"/> entries between the value pairs written.</param>
        </member>
        <member name="M:Spine.VertexAttachment.ApplyDeform(Spine.VertexAttachment)">
            <summary>Returns true if a deform originally applied to the specified attachment should be applied to this attachment.</summary>
        </member>
        <member name="T:Spine.Bone">
            <summary>
            Stores a bone's current pose.
            <para>
            A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a
            local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a
            constraint or application code modifies the world transform after it was computed from the local transform.
            </para>
            </summary>
        </member>
        <member name="P:Spine.Bone.X">
            <summary>The local X translation.</summary>
        </member>
        <member name="P:Spine.Bone.Y">
            <summary>The local Y translation.</summary>
        </member>
        <member name="P:Spine.Bone.Rotation">
            <summary>The local rotation.</summary>
        </member>
        <member name="P:Spine.Bone.ScaleX">
            <summary>The local scaleX.</summary>
        </member>
        <member name="P:Spine.Bone.ScaleY">
            <summary>The local scaleY.</summary>
        </member>
        <member name="P:Spine.Bone.ShearX">
            <summary>The local shearX.</summary>
        </member>
        <member name="P:Spine.Bone.ShearY">
            <summary>The local shearY.</summary>
        </member>
        <member name="P:Spine.Bone.AppliedRotation">
            <summary>The rotation, as calculated by any constraints.</summary>
        </member>
        <member name="P:Spine.Bone.AX">
            <summary>The applied local x translation.</summary>
        </member>
        <member name="P:Spine.Bone.AY">
            <summary>The applied local y translation.</summary>
        </member>
        <member name="P:Spine.Bone.AScaleX">
            <summary>The applied local scaleX.</summary>
        </member>
        <member name="P:Spine.Bone.AScaleY">
            <summary>The applied local scaleY.</summary>
        </member>
        <member name="P:Spine.Bone.AShearX">
            <summary>The applied local shearX.</summary>
        </member>
        <member name="P:Spine.Bone.AShearY">
            <summary>The applied local shearY.</summary>
        </member>
        <member name="P:Spine.Bone.WorldScaleX">
            <summary>Returns the magnitide (always positive) of the world scale X.</summary>
        </member>
        <member name="P:Spine.Bone.WorldScaleY">
            <summary>Returns the magnitide (always positive) of the world scale Y.</summary>
        </member>
        <member name="M:Spine.Bone.#ctor(Spine.BoneData,Spine.Skeleton,Spine.Bone)">
            <param name="parent">May be null.</param>
        </member>
        <member name="M:Spine.Bone.Update">
            <summary>Same as <see cref="M:Spine.Bone.UpdateWorldTransform"/>. This method exists for Bone to implement <see cref="T:Spine.IUpdatable"/>.</summary>
        </member>
        <member name="M:Spine.Bone.UpdateWorldTransform">
            <summary>Computes the world transform using the parent bone and this bone's local transform.</summary>
        </member>
        <member name="M:Spine.Bone.UpdateWorldTransform(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Computes the world transform using the parent bone and the specified local transform.</summary>
        </member>
        <member name="M:Spine.Bone.UpdateAppliedTransform">
            <summary>
            Computes the individual applied transform values from the world transform. This can be useful to perform processing using
            the applied transform after the world transform has been modified directly (eg, by a constraint)..
            
            Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation.
            </summary>
        </member>
        <member name="M:Spine.Bone.RotateWorld(System.Single)">
            <summary>
            Rotates the world transform the specified amount and sets isAppliedValid to false.
            </summary>
            <param name="degrees">Degrees.</param>
        </member>
        <member name="P:Spine.BoneData.Index">
            <summary>The index of the bone in Skeleton.Bones</summary>
        </member>
        <member name="P:Spine.BoneData.Name">
            <summary>The name of the bone, which is unique within the skeleton.</summary>
        </member>
        <member name="P:Spine.BoneData.Parent">
            <summary>May be null.</summary>
        </member>
        <member name="P:Spine.BoneData.X">
            <summary>Local X translation.</summary>
        </member>
        <member name="P:Spine.BoneData.Y">
            <summary>Local Y translation.</summary>
        </member>
        <member name="P:Spine.BoneData.Rotation">
            <summary>Local rotation.</summary>
        </member>
        <member name="P:Spine.BoneData.ScaleX">
            <summary>Local scaleX.</summary>
        </member>
        <member name="P:Spine.BoneData.ScaleY">
            <summary>Local scaleY.</summary>
        </member>
        <member name="P:Spine.BoneData.ShearX">
            <summary>Local shearX.</summary>
        </member>
        <member name="P:Spine.BoneData.ShearY">
            <summary>Local shearY.</summary>
        </member>
        <member name="P:Spine.BoneData.TransformMode">
            <summary>The transform mode for how parent world transforms affect this bone.</summary>
        </member>
        <member name="M:Spine.BoneData.#ctor(System.Int32,System.String,Spine.BoneData)">
            <param name="parent">May be null.</param>
        </member>
        <member name="T:Spine.Event">
            <summary>Stores the current pose values for an Event.</summary>
        </member>
        <member name="P:Spine.Event.Time">
            <summary>The animation time this event was keyed.</summary>
        </member>
        <member name="T:Spine.EventData">
            <summary>Stores the setup pose values for an Event.</summary>
        </member>
        <member name="P:Spine.EventData.Name">
            <summary>The name of the event, which is unique within the skeleton.</summary>
        </member>
        <member name="M:Spine.ExposedList`1.Pop">
            <summary>Pops the last item of the list. If the list is empty, Pop throws an InvalidOperationException.</summary>
        </member>
        <member name="T:Spine.IConstraint">
            <summary>The interface for all constraints.</summary>
        </member>
        <member name="P:Spine.IConstraint.Order">
            <summary>The ordinal for the order a skeleton's constraints will be applied.</summary>
        </member>
        <member name="M:Spine.IkConstraint.Apply">
            <summary>Applies the constraint to the constrained bones.</summary>
        </member>
        <member name="M:Spine.IkConstraint.Apply(Spine.Bone,System.Single,System.Single,System.Single)">
            <summary>Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified
            in the world coordinate system.</summary>
        </member>
        <member name="M:Spine.IkConstraint.Apply(Spine.Bone,Spine.Bone,System.Single,System.Single,System.Int32,System.Single)">
            <summary>Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as
            possible. The target is specified in the world coordinate system.</summary>
            <param name="child">A direct descendant of the parent bone.</param>
        </member>
        <member name="T:Spine.IkConstraintData">
            <summary>Stores the setup pose for an IkConstraint.</summary>
        </member>
        <member name="P:Spine.IkConstraintData.Name">
            <summary>The IK constraint's name, which is unique within the skeleton.</summary>
        </member>
        <member name="P:Spine.IkConstraintData.Bones">
            <summary>The bones that are constrained by this IK Constraint.</summary>
        </member>
        <member name="P:Spine.IkConstraintData.Target">
            <summary>The bone that is the IK target.</summary>
        </member>
        <member name="P:Spine.IkConstraintData.BendDirection">
            <summary>Controls the bend direction of the IK bones, either 1 or -1.</summary>
        </member>
        <member name="M:Spine.MathUtils.Sin(System.Single)">
            <summary>Returns the sine in radians from a lookup table.</summary>
        </member>
        <member name="M:Spine.MathUtils.Cos(System.Single)">
            <summary>Returns the cosine in radians from a lookup table.</summary>
        </member>
        <member name="M:Spine.MathUtils.SinDeg(System.Single)">
            <summary>Returns the sine in radians from a lookup table.</summary>
        </member>
        <member name="M:Spine.MathUtils.CosDeg(System.Single)">
            <summary>Returns the cosine in radians from a lookup table.</summary>
        </member>
        <member name="M:Spine.MathUtils.Atan2(System.Single,System.Single)">
            <summary>Returns atan2 in radians, faster but less accurate than Math.Atan2. Average error of 0.00231 radians (0.1323
            degrees), largest error of 0.00488 radians (0.2796 degrees).</summary>
        </member>
        <member name="M:Spine.PathConstraint.Apply">
            <summary>Applies the constraint to the constrained bones.</summary>
        </member>
        <member name="M:Spine.Skeleton.UpdateCache">
            <summary>Caches information about bones and constraints. Must be called if bones, constraints or weighted path attachments are added
            or removed.</summary>
        </member>
        <member name="M:Spine.Skeleton.UpdateWorldTransform">
            <summary>Updates the world transform for each bone and applies constraints.</summary>
        </member>
        <member name="M:Spine.Skeleton.SetToSetupPose">
            <summary>Sets the bones, constraints, and slots to their setup pose values.</summary>
        </member>
        <member name="M:Spine.Skeleton.SetBonesToSetupPose">
            <summary>Sets the bones and constraints to their setup pose values.</summary>
        </member>
        <member name="M:Spine.Skeleton.FindBone(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.FindBoneIndex(System.String)">
            <returns>-1 if the bone was not found.</returns>
        </member>
        <member name="M:Spine.Skeleton.FindSlot(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.FindSlotIndex(System.String)">
            <returns>-1 if the bone was not found.</returns>
        </member>
        <member name="M:Spine.Skeleton.SetSkin(System.String)">
            <summary>Sets a skin by name (see SetSkin).</summary>
        </member>
        <member name="M:Spine.Skeleton.SetSkin(Spine.Skin)">
            <summary>
            <para>Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. 
            If there was no old skin, each slot's setup mode attachment is attached from the new skin.</para>
            <para>After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling 
            <see cref="M:Spine.Skeleton.SetSlotsToSetupPose"/>. 
            Also, often <see cref="M:Spine.AnimationState.Apply(Spine.Skeleton)"/> is called before the next time the 
            skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.</para>
            </summary>
            <param name="newSkin">May be null.</param>
        </member>
        <member name="M:Spine.Skeleton.GetAttachment(System.String,System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.GetAttachment(System.Int32,System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.SetAttachment(System.String,System.String)">
            <param name="attachmentName">May be null.</param>
        </member>
        <member name="M:Spine.Skeleton.FindIkConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.FindTransformConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.FindPathConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.Skeleton.GetBounds(System.Single@,System.Single@,System.Single@,System.Single@,System.Single[]@)">
            <summary>Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.</summary>
            <param name="x">The horizontal distance between the skeleton origin and the left side of the AABB.</param>
            <param name="y">The vertical distance between the skeleton origin and the bottom side of the AABB.</param>
            <param name="width">The width of the AABB</param>
            <param name="height">The height of the AABB.</param>
            <param name="vertexBuffer">Reference to hold a float[]. May be a null reference. This method will assign it a new float[] with the appropriate size as needed.</param>
        </member>
        <member name="M:Spine.SkeletonBinary.GetVersionString(System.IO.Stream)">
            <summary>Returns the version string of binary skeleton data.</summary>
        </member>
        <member name="M:Spine.SkeletonBinary.ReadSkin(System.IO.Stream,Spine.SkeletonData,System.String,System.Boolean)">
            <returns>May be null.</returns>
        </member>
        <member name="T:Spine.SkeletonBounds">
            <summary>
            Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.
            The polygon vertices are provided along with convenience methods for doing hit detection.
            </summary>
        </member>
        <member name="M:Spine.SkeletonBounds.Update(Spine.Skeleton,System.Boolean)">
            <summary>
            Clears any previous polygons, finds all visible bounding box attachments,
            and computes the world vertices for each bounding box's polygon.</summary>
            <param name="skeleton">The skeleton.</param>
            <param name="updateAabb">
            If true, the axis aligned bounding box containing all the polygons is computed.
            If false, the SkeletonBounds AABB methods will always return true.
            </param>
        </member>
        <member name="M:Spine.SkeletonBounds.AabbContainsPoint(System.Single,System.Single)">
            <summary>Returns true if the axis aligned bounding box contains the point.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.AabbIntersectsSegment(System.Single,System.Single,System.Single,System.Single)">
            <summary>Returns true if the axis aligned bounding box intersects the line segment.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.AabbIntersectsSkeleton(Spine.SkeletonBounds)">
            <summary>Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.ContainsPoint(Spine.Polygon,System.Single,System.Single)">
            <summary>Returns true if the polygon contains the point.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.ContainsPoint(System.Single,System.Single)">
            <summary>Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
            efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.IntersectsSegment(System.Single,System.Single,System.Single,System.Single)">
            <summary>Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
            more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true.</summary>
        </member>
        <member name="M:Spine.SkeletonBounds.IntersectsSegment(Spine.Polygon,System.Single,System.Single,System.Single,System.Single)">
            <summary>Returns true if the polygon contains the line segment.</summary>
        </member>
        <member name="M:Spine.SkeletonClipping.Clip(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Spine.ExposedList{System.Single},Spine.ExposedList{System.Single})">
            Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping
            area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. 
        </member>
        <member name="T:Spine.SkeletonData">
            <summary>Stores the setup pose and all of the stateless data for a skeleton.</summary>
        </member>
        <member name="P:Spine.SkeletonData.Bones">
            <summary>The skeleton's bones, sorted parent first. The root bone is always the first bone.</summary>
        </member>
        <member name="P:Spine.SkeletonData.Skins">
            <summary>All skins, including the default skin.</summary>
        </member>
        <member name="P:Spine.SkeletonData.DefaultSkin">
            <summary>
            The skeleton's default skin.
            By default this skin contains all attachments that were not in a skin in Spine.
            </summary>
            <return>May be null.</return>
        </member>
        <member name="P:Spine.SkeletonData.Version">
            <summary>The Spine version used to export this data, or null.</summary>
        </member>
        <member name="P:Spine.SkeletonData.Fps">
            <summary>
            The dopesheet FPS in Spine. Available only when nonessential data was exported.</summary>
        </member>
        <member name="M:Spine.SkeletonData.FindBone(System.String)">
            <summary>
            Finds a bone by comparing each bone's name.
            It is more efficient to cache the results of this method than to call it multiple times.</summary>
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindBoneIndex(System.String)">
            <returns>-1 if the bone was not found.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindSlot(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindSlotIndex(System.String)">
            <returns>-1 if the slot was not found.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindSkin(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindEvent(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindAnimation(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindIkConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindTransformConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindPathConstraint(System.String)">
            <returns>May be null.</returns>
        </member>
        <member name="M:Spine.SkeletonData.FindPathConstraintIndex(System.String)">
            <returns>-1 if the path constraint was not found.</returns>
        </member>
        <member name="T:Spine.Skin">
            <summary>Stores attachments by slot index and attachment name.
            <para>See SkeletonData <see cref="P:Spine.SkeletonData.DefaultSkin"/>, Skeleton <see cref="P:Spine.Skeleton.Skin"/>, and 
            <a href="http://esotericsoftware.com/spine-runtime-skins">Runtime skins</a> in the Spine Runtimes Guide.</para>
            </summary>
        </member>
        <member name="M:Spine.Skin.AddAttachment(System.Int32,System.String,Spine.Attachment)">
            <summary>Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.</summary>
        </member>
        <member name="M:Spine.Skin.GetAttachment(System.Int32,System.String)">
            <summary>Returns the attachment for the specified slot index and name, or null.</summary>
            <returns>May be null.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Spine.Skin.FindNamesForSlot(System.Int32,System.Collections.Generic.List{System.String})" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Skin.FindAttachmentsForSlot(System.Int32,System.Collections.Generic.List{Spine.Attachment})" -->
        <member name="M:Spine.Skin.AttachAll(Spine.Skeleton,Spine.Skin)">
            <summary>Attach all attachments from this skin if the corresponding attachment from the old skin is currently attached.</summary>
        </member>
        <member name="P:Spine.Slot.Attachment">
            <summary>May be null.</summary>
        </member>
        <member name="P:Spine.SlotData.AttachmentName">
            <summary>May be null.</summary>
        </member>
        <member name="T:Spine.Unity.AtlasAsset">
            <summary>Loads and stores a Spine atlas and list of materials.</summary>
        </member>
        <member name="M:Spine.Unity.AtlasAsset.CreateRuntimeInstance(UnityEngine.TextAsset,UnityEngine.Material[],System.Boolean)">
            <summary>
            Creates a runtime AtlasAsset</summary>
        </member>
        <member name="M:Spine.Unity.AtlasAsset.CreateRuntimeInstance(UnityEngine.TextAsset,UnityEngine.Texture2D[],UnityEngine.Material,System.Boolean)">
            <summary>
            Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="M:Spine.Unity.AtlasAsset.CreateRuntimeInstance(UnityEngine.TextAsset,UnityEngine.Material[],System.Boolean)"/></summary>
        </member>
        <member name="M:Spine.Unity.AtlasAsset.CreateRuntimeInstance(UnityEngine.TextAsset,UnityEngine.Texture2D[],UnityEngine.Shader,System.Boolean)">
            <summary>
            Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="M:Spine.Unity.AtlasAsset.CreateRuntimeInstance(UnityEngine.TextAsset,UnityEngine.Material[],System.Boolean)"/></summary>
        </member>
        <member name="M:Spine.Unity.AtlasAsset.GetAtlas">
            <returns>The atlas or null if it could not be loaded.</returns>
        </member>
        <member name="M:Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance(UnityEngine.TextAsset,Spine.Unity.AtlasAsset,System.Boolean,System.Single)">
            <summary>
            Creates a runtime SkeletonDataAsset.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance(UnityEngine.TextAsset,Spine.Unity.AtlasAsset[],System.Boolean,System.Single)">
            <summary>
            Creates a runtime SkeletonDataAsset.</summary>
        </member>
        <member name="T:Spine.Unity.BoneFollower">
            <summary>Sets a GameObject's transform to match a bone on a Spine skeleton.</summary>
        </member>
        <member name="F:Spine.Unity.BoneFollower.boneName">
            <summary>If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.</summary>
        </member>
        <member name="F:Spine.Unity.BoneFollower.bone">
            <summary>
            The bone.
            </summary>
        </member>
        <member name="M:Spine.Unity.BoneFollower.SetBone(System.String)">
            <summary>
            Sets the target bone by its bone name. Returns false if no bone was found.</summary>
        </member>
        <member name="T:Spine.Unity.ISkeletonAnimation">
            <summary>A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.</summary>
        </member>
        <member name="T:Spine.Unity.ISkeletonComponent">
            <summary>A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.</summary>
        </member>
        <member name="P:Spine.Unity.ISkeletonComponent.SkeletonDataAsset">
            <summary>Gets the SkeletonDataAsset of the Spine Component.</summary>
        </member>
        <member name="P:Spine.Unity.ISkeletonComponent.Skeleton">
            <summary>Gets the Spine.Skeleton instance of the Spine Component. This is equivalent to SkeletonRenderer's .skeleton.</summary>
        </member>
        <member name="T:Spine.Unity.IAnimationStateComponent">
            <summary>A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.</summary>
        </member>
        <member name="P:Spine.Unity.IAnimationStateComponent.AnimationState">
            <summary>Gets the Spine.AnimationState of the animated Spine Component. This is equivalent to SkeletonAnimation.state.</summary>
        </member>
        <member name="M:Spine.Unity.SpineMesh.NewMesh">
            <summary>Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.</summary>
        </member>
        <member name="T:Spine.Unity.SubmeshInstruction">
            <summary>Instructions for how to generate a mesh or submesh out of a range of slots in a given skeleton.</summary>
        </member>
        <member name="P:Spine.Unity.SubmeshInstruction.SlotCount">
            <summary>The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.</summary>
        </member>
        <member name="F:Spine.Unity.MeshGeneratorBuffers.vertexCount">
            <summary>The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.</summary>
        </member>
        <member name="F:Spine.Unity.MeshGeneratorBuffers.vertexBuffer">
            <summary> Vertex positions. To be used for UnityEngine.Mesh.vertices.</summary>
        </member>
        <member name="F:Spine.Unity.MeshGeneratorBuffers.uvBuffer">
            <summary> Vertex UVs. To be used for UnityEngine.Mesh.uvs.</summary>
        </member>
        <member name="F:Spine.Unity.MeshGeneratorBuffers.colorBuffer">
            <summary> Vertex colors. To be used for UnityEngine.Mesh.colors32.</summary>
        </member>
        <member name="F:Spine.Unity.MeshGeneratorBuffers.meshGenerator">
            <summary> The Spine rendering component's MeshGenerator. </summary>
        </member>
        <member name="M:Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(UnityEngine.Vector4[]@,UnityEngine.Vector2[]@,System.Int32)">
            <summary>Step 1 of solving tangents. Ensure you have buffers of the correct size.</summary>
            <param name="tangentBuffer">Eventual Vector4[] tangent buffer to assign to Mesh.tangents.</param>
            <param name="tempTanBuffer">Temporary Vector2 buffer for calculating directions.</param>
            <param name="vertexCount">Number of vertices that require tangents (or the size of the vertex array)</param>
        </member>
        <member name="M:Spine.Unity.MeshGenerator.SolveTangents2DTriangles(UnityEngine.Vector2[],System.Int32[],System.Int32,UnityEngine.Vector3[],UnityEngine.Vector2[],System.Int32)">
            <summary>Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.</summary>
            <param name="tempTanBuffer">A temporary Vector3[] for calculating tangents.</param>
            <param name="vertices">The mesh's current vertex position buffer.</param>
            <param name="triangles">The mesh's current triangles buffer.</param>
            <param name="uvs">The mesh's current uvs buffer.</param>
            <param name="vertexCount">Number of vertices that require tangents (or the size of the vertex array)</param>
            <param name = "triangleCount">The number of triangle indexes in the triangle array to be used.</param>
        </member>
        <member name="M:Spine.Unity.MeshGenerator.SolveTangents2DBuffer(UnityEngine.Vector4[],UnityEngine.Vector2[],System.Int32)">
            <summary>Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.</summary>
            <param name="tangents">A Vector4[] that will eventually be used to set Mesh.tangents</param>
            <param name="tempTanBuffer">A temporary Vector3[] for calculating tangents.</param>
            <param name="vertexCount">Number of vertices that require tangents (or the size of the vertex array)</param>
        </member>
        <member name="T:Spine.Unity.MeshRendererBuffers.SmartMesh">
            <summary>This is a Mesh that also stores the instructions SkeletonRenderer generated for it.</summary>
        </member>
        <member name="T:Spine.Unity.Modules.AtlasRegionAttacher">
            <summary>
            Example code for a component that replaces the default attachment of a slot with an image from a Spine atlas.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.GetRegion(Spine.Attachment)">
            <summary>
            Tries to get the region (image) of a renderable attachment. If the attachment is not renderable, it returns null.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.GetRegion(Spine.RegionAttachment)">
            <summary>Gets the region (image) of a RegionAttachment</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.GetRegion(Spine.MeshAttachment)">
            <summary>Gets the region (image) of a MeshAttachment</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetRegion(Spine.Attachment,Spine.AtlasRegion,System.Boolean)">
            <summary>
            Tries to set the region (image) of a renderable attachment. If the attachment is not renderable, nothing is applied.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetRegion(Spine.RegionAttachment,Spine.AtlasRegion,System.Boolean)">
            <summary>Sets the region (image) of a RegionAttachment</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetRegion(Spine.MeshAttachment,Spine.AtlasRegion,System.Boolean)">
            <summary>Sets the region (image) of a MeshAttachment</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(UnityEngine.Sprite,UnityEngine.Material,System.Single)">
            <summary>
            Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided./// </summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(UnityEngine.Sprite,Spine.AtlasPage,System.Single)">
            <summary>
            Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided./// </summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone(UnityEngine.Sprite,UnityEngine.Shader,UnityEngine.TextureFormat,System.Boolean,UnityEngine.Material,System.Single)">
            <summary>
            Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data. Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton"</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(Spine.AtlasRegion,System.String,System.Single,System.Single)">
            <summary>
            Creates a new RegionAttachment from a given AtlasRegion.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetScale(Spine.RegionAttachment,UnityEngine.Vector2)">
            <summary> Sets the scale. Call regionAttachment.UpdateOffset to apply the change.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetScale(Spine.RegionAttachment,System.Single,System.Single)">
            <summary> Sets the scale. Call regionAttachment.UpdateOffset to apply the change.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset(Spine.RegionAttachment,UnityEngine.Vector2)">
            <summary> Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset(Spine.RegionAttachment,System.Single,System.Single)">
            <summary> Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentRegionExtensions.SetRotation(Spine.RegionAttachment,System.Single)">
            <summary> Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(UnityEngine.Texture2D,UnityEngine.Material,UnityEngine.TextureFormat,System.Boolean)">
            <summary>
            Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(UnityEngine.Texture2D,UnityEngine.Shader,UnityEngine.TextureFormat,System.Boolean,UnityEngine.Material)">
            <summary>
            Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(UnityEngine.Material)">
            <summary>
            Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToAtlasRegion(UnityEngine.Sprite,Spine.AtlasPage)">
            <summary>
            Creates a Spine.AtlasRegion from a UnityEngine.Sprite.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToAtlasRegion(UnityEngine.Sprite,UnityEngine.Material)">
            <summary>
            Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(UnityEngine.Sprite,UnityEngine.Shader,UnityEngine.TextureFormat,System.Boolean,UnityEngine.Material)">
            <summary>
            Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetRepackedAttachments(System.Collections.Generic.List{Spine.Attachment},System.Collections.Generic.List{Spine.Attachment},UnityEngine.Material,UnityEngine.Material@,UnityEngine.Texture2D@,System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.String,System.Boolean)">
            <summary>
            Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments, but mapped to a new single texture using the same material.</summary>
            <param name="sourceAttachments">The list of attachments to be repacked.</param>
            <param name = "outputAttachments">The List(Attachment) to populate with the newly created Attachment objects.</param>
            
            <param name="materialPropertySource">May be null. If no Material property source is provided, no special </param>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetRepackedSkin(Spine.Skin,System.String,UnityEngine.Material,UnityEngine.Material@,UnityEngine.Texture2D@,System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean)">
            <summary>
            Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas comprised of all the regions from the original skin.</summary>
            <remarks>No Spine.Atlas object is created so there is no way to find AtlasRegions except through the Attachments using them.</remarks>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetRepackedSkin(Spine.Skin,System.String,UnityEngine.Shader,UnityEngine.Material@,UnityEngine.Texture2D@,System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,UnityEngine.Material,System.Boolean)">
            <summary>
            Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas comprised of all the regions from the original skin.</summary>
            <remarks>No Spine.Atlas object is created so there is no way to find AtlasRegions except through the Attachments using them.</remarks>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.ToTexture(Spine.AtlasRegion,System.Boolean,UnityEngine.TextureFormat,System.Boolean)">
            <summary>Creates a new Texture2D object based on an AtlasRegion.
            If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(UnityEngine.Rect,System.Int32)">
            <summary>
            Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetUnityRect(Spine.AtlasRegion)">
            <summary>
            Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
            This overload relies on region.page.height being correctly set.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetUnityRect(Spine.AtlasRegion,System.Int32)">
            <summary>
            Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(Spine.AtlasRegion,System.Boolean)">
            <summary>
            Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.UVRectToTextureRect(UnityEngine.Rect,System.Int32,System.Int32)">
            <summary>
            Denormalize a uvRect into a texture-space Rect.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.TextureRectToUVRect(UnityEngine.Rect,System.Int32,System.Int32)">
            <summary>
            Normalize a texture Rect into UV coordinates.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(UnityEngine.Rect,System.String,Spine.AtlasPage,System.Single,System.Single,System.Boolean)">
            <summary>
            Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetAtlasRegion(Spine.Attachment)">
            <summary>
            Tries to get the backing AtlasRegion of an attachment if it is renderable. Returns null for non-renderable attachments.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AtlasUtilities.GetMainTexture(Spine.AtlasRegion)">
            <summary>
            Convenience method for getting the main texture of the material of the page of the region.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.UnshareSkin(Spine.Skeleton,System.Boolean,System.Boolean,Spine.AnimationState)">
            <summary>
            Convenience method for duplicating a skeleton's current active skin so changes to it will not affect other skeleton instances. .</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.GetClone(Spine.Skin)">
            <summary>
            Gets a shallow copy of the skin. The cloned skin's attachments are shared with the original skin.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.SetAttachment(Spine.Skin,System.String,System.String,Spine.Attachment,Spine.Skeleton)">
            <summary>Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.GetAttachment(Spine.Skin,System.String,System.String,Spine.Skeleton)">
            <summary>Gets an attachment from the skin for the specified slot index and name.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.SetAttachment(Spine.Skin,System.Int32,System.String,Spine.Attachment)">
            <summary>Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.RemoveAttachment(Spine.Skin,System.String,System.String,Spine.Skeleton)">
            <summary>Removes the attachment. Returns true if the element is successfully found and removed; otherwise, false.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.SkinUtilities.RemoveAttachment(Spine.Skin,System.Int32,System.String)">
            <summary>Removes the attachment. Returns true if the element is successfully found and removed; otherwise, false.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetClone(Spine.Attachment,System.Boolean)">
            <summary>
            Clones the attachment.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetClone(Spine.MeshAttachment)">
            <summary>
            Returns a clone of the MeshAttachment. This will cause Deform animations to stop working unless you explicity set the .parentMesh to the original.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh(Spine.MeshAttachment,System.String,Spine.AtlasRegion,System.Boolean)">
            <summary>
            Returns a new linked mesh linked to this MeshAttachment. It will be mapped to the AtlasRegion provided.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh(Spine.MeshAttachment,UnityEngine.Sprite,UnityEngine.Shader,System.Boolean,UnityEngine.Material)">
            <summary>
            Returns a new linked mesh linked to this MeshAttachment. It will be mapped to an AtlasRegion generated from a Sprite. The AtlasRegion will be mapped to a new Material based on the shader.
            For better caching and batching, use GetLinkedMesh(string, AtlasRegion, bool)</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh(Spine.MeshAttachment,UnityEngine.Sprite,UnityEngine.Material,System.Boolean)">
            <summary>
            Returns a new linked mesh linked to this MeshAttachment. It will be mapped to an AtlasRegion generated from a Sprite. The AtlasRegion will be mapped to a new Material based on the shader.
            For better caching and batching, use GetLinkedMesh(string, AtlasRegion, bool)</summary>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(Spine.Attachment,UnityEngine.Sprite,UnityEngine.Material,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets a clone of the attachment remapped with a sprite image.</summary>
            <returns>The remapped clone.</returns>
            <param name="o">The original attachment.</param>
            <param name="sprite">The sprite whose texture to use.</param>
            <param name="sourceMaterial">The source material used to copy the shader and material properties from.</param>
            <param name="premultiplyAlpha">If <c>true</c>, a premultiply alpha clone of the original texture will be created.</param>
            <param name="cloneMeshAsLinked">If <c>true</c> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.</param>
            <param name="useOriginalRegionSize">If <c>true</c> the size of the original attachment will be followed, instead of using the Sprite size.</param>
        </member>
        <member name="M:Spine.Unity.Modules.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(Spine.Attachment,Spine.AtlasRegion,System.Boolean,System.Boolean,System.Single)">
            <summary>
            Gets a clone of the attachment remapped with an atlasRegion image.</summary>
            <returns>The remapped clone.</returns>
            <param name="o">The original attachment.</param>
            <param name="atlasRegion">Atlas region.</param>
            <param name="cloneMeshAsLinked">If <c>true</c> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.</param>
            <param name="useOriginalRegionSize">If <c>true</c> the size of the original attachment will be followed, instead of using the Sprite size.</param>
            <param name="scale">Unity units per pixel scale used to scale the atlas region size when not using the original region size.</param>
        </member>
        <member name="M:Spine.Unity.Modules.SpriteAttacher.Attach">
            <summary>Update the slot's attachment to the Attachment generated from the sprite.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll.Apply">
            <summary>Instantiates the ragdoll simulation and applies its transforms to the skeleton.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll.SmoothMix(System.Single,System.Single)">
            <summary>Transitions the mix value from the current value to a target value.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll.SetSkeletonPosition(UnityEngine.Vector3)">
            <summary>Set the transform world position while preserving the ragdoll parts world position.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll.Remove">
            <summary>Removes the ragdoll instance and effect from the animated skeleton.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.Apply">
            <summary>Instantiates the ragdoll simulation and applies its transforms to the skeleton.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.SmoothMix(System.Single,System.Single)">
            <summary>Transitions the mix value from the current value to a target value.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.SetSkeletonPosition(UnityEngine.Vector3)">
            <summary>Set the transform world position while preserving the ragdoll parts world position.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.Remove">
            <summary>Removes the ragdoll instance and effect from the animated skeleton.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.RecursivelyCreateBoneProxies(Spine.Bone)">
            <summary>Generates the ragdoll simulation's Transform and joint setup.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRagdoll2D.UpdateSpineSkeleton(Spine.Unity.ISkeletonAnimation)">
            <summary>Performed every skeleton animation update to translate Unity Transforms positions into Spine bone transforms.</summary>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRenderSeparator.AddToSkeletonRenderer(Spine.Unity.SkeletonRenderer,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.</summary>
            <returns>The to skeleton renderer.</returns>
            <param name="skeletonRenderer">The target SkeletonRenderer or SkeletonAnimation.</param>
            <param name="sortingLayerID">Sorting layer to be used for the parts renderers.</param>
            <param name="extraPartsRenderers">Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.</param>
            <param name="sortingOrderIncrement">The integer to increment the sorting order per SkeletonPartsRenderer to separate them.</param>
            <param name="baseSortingOrder">The sorting order value of the first SkeletonPartsRenderer.</param>
            <param name="addMinimumPartsRenderers">If set to <c>true</c>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.</param>
        </member>
        <member name="M:Spine.Unity.Modules.SkeletonRenderSeparator.AddPartsRenderer(System.Int32)">
            <summary>Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.</summary>
        </member>
        <member name="M:Spine.Unity.BoundingBoxFollower.Initialize(System.Boolean)">
            <summary>
            Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.</summary>
        </member>
        <member name="M:Spine.Unity.BoundingBoxFollower.MatchAttachment(Spine.Attachment)">
            <summary>Sets the current collider to match attachment.</summary>
            <param name="attachment">If the attachment is not a bounding box, it will be treated as null.</param>
        </member>
        <member name="F:Spine.Unity.BoneFollowerGraphic.boneName">
            <summary>If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.</summary>
        </member>
        <member name="M:Spine.Unity.BoneFollowerGraphic.SetBone(System.String)">
            <summary>
            Sets the target bone by its bone name. Returns false if no bone was found.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonGraphic.OnPostProcessVertices">
            <summary> Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.</summary>
        </member>
        <member name="T:Spine.Unity.WaitForSpineAnimationComplete">
            <summary>
            Use this as a condition-blocking yield instruction for Unity Coroutines. 
            The routine will pause until the AnimationState.TrackEntry fires its Complete event.</summary>
        </member>
        <member name="M:Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor(Spine.TrackEntry)">
            <summary>
            One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure. 
            Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.</summary>
        </member>
        <member name="T:Spine.Unity.WaitForSpineEvent">
            <summary>
            Use this as a condition-blocking yield instruction for Unity Coroutines. 
            The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.</summary>
        </member>
        <member name="P:Spine.Unity.WaitForSpineEvent.WillUnsubscribeAfterFiring">
            <summary>
            By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event. 
            If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.</summary>
        </member>
        <member name="T:Spine.Unity.WaitForSpineTrackEntryEnd">
            <summary>
            Use this as a condition-blocking yield instruction for Unity Coroutines. 
            The routine will pause until the AnimationState.TrackEntry fires its End event.</summary>
        </member>
        <member name="M:Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor(Spine.TrackEntry)">
            <summary>
            One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure. 
            Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.</summary>
        </member>
        <member name="F:Spine.Unity.SkeletonAnimation.state">
            <summary>
            This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it. 
            Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start</summary>
        </member>
        <member name="P:Spine.Unity.SkeletonAnimation.AnimationState">
            <summary>
            This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it. 
            Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimation.UpdateLocal">
            <summary>
            Occurs after the animations are applied and before world space values are resolved.
            Use this callback when you want to set bone local values.
            </summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimation.UpdateWorld">
            <summary>
            Occurs after the Skeleton's bone world space values are resolved (including all constraints).
            Using this callback will cause the world space values to be solved an extra time.
            Use this callback if want to use bone world space values, and also set bone local values.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimation.UpdateComplete">
            <summary>
            Occurs after the Skeleton's bone world space values are resolved (including all constraints).
            Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
            This callback can also be used when setting world position and the bone matrix.</summary>
        </member>
        <member name="F:Spine.Unity.SkeletonAnimation.loop">
            <summary>Whether or not <see cref="P:Spine.Unity.SkeletonAnimation.AnimationName"/> should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.</summary>
        </member>
        <member name="F:Spine.Unity.SkeletonAnimation.timeScale">
            <summary>
            The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.</summary>
            <remarks>AnimationState and TrackEntry also have their own timeScale. These are combined multiplicatively.</remarks>
        </member>
        <member name="M:Spine.Unity.SkeletonAnimation.AddToGameObject(UnityEngine.GameObject,Spine.Unity.SkeletonDataAsset)">
            <summary>Adds and prepares a SkeletonAnimation component to a GameObject at runtime.</summary>
            <returns>The newly instantiated SkeletonAnimation</returns>
        </member>
        <member name="M:Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject(Spine.Unity.SkeletonDataAsset)">
            <summary>Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.</summary>
            <returns>The newly instantiated SkeletonAnimation component.</returns>
        </member>
        <member name="M:Spine.Unity.SkeletonAnimation.Update(System.Single)">
            <summary>Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimator.UpdateLocal">
            <summary>
            Occurs after the animations are applied and before world space values are resolved.
            Use this callback when you want to set bone local values.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimator.UpdateWorld">
            <summary>
            Occurs after the Skeleton's bone world space values are resolved (including all constraints).
            Using this callback will cause the world space values to be solved an extra time.
            Use this callback if want to use bone world space values, and also set bone local values.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonAnimator.UpdateComplete">
            <summary>
            Occurs after the Skeleton's bone world space values are resolved (including all constraints).
            Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
            This callback can also be used when setting world position and the bone matrix.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.SetPosition(Spine.Bone,UnityEngine.Vector2)">
            <summary>Sets the bone's (local) X and Y according to a Vector2</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.SetPosition(Spine.Bone,UnityEngine.Vector3)">
            <summary>Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetLocalPosition(Spine.Bone)">
            <summary>Gets the bone's local X and Y as a Vector2.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition(Spine.Bone)">
            <summary>Gets the position of the bone in Skeleton-space.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition(Spine.Bone,UnityEngine.Vector2)">
            <summary>Gets a local offset from the bone and converts it into Skeleton-space.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetWorldPosition(Spine.Bone,UnityEngine.Transform)">
            <summary>Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetQuaternion(Spine.Bone)">
            <summary>Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetLocalQuaternion(Spine.Bone)">
            <summary>Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetWorldPosition(Spine.PointAttachment,Spine.Slot,UnityEngine.Transform)">
            <summary>Gets the PointAttachment's Unity World position using its Spine GameObject Transform.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetWorldPosition(Spine.PointAttachment,Spine.Bone,UnityEngine.Transform)">
            <summary>Gets the PointAttachment's Unity World position using its Spine GameObject Transform.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetMatrix4x4(Spine.Bone)">
            <summary>Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(Spine.Bone,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.WorldToLocal(Spine.Bone,UnityEngine.Vector2)">
            <summary>UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace(Spine.Bone,UnityEngine.Vector2)">
            <summary>Sets the skeleton-space position of a bone.</summary>
            <returns>The local position in its parent bone space, or in skeleton space if it is the root bone.</returns>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetLocalVertices(Spine.VertexAttachment,Spine.Slot,UnityEngine.Vector2[])">
            <summary>Fills a Vector2 buffer with local vertices.</summary>
            <param name="va">The VertexAttachment</param>
            <param name="slot">Slot where the attachment belongs.</param>
            <param name="buffer">Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.</param>
        </member>
        <member name="M:Spine.Unity.SkeletonExtensions.GetWorldVertices(Spine.VertexAttachment,Spine.Slot,UnityEngine.Vector2[])">
            <summary>Calculates world vertices and fills a Vector2 buffer.</summary>
            <param name="a">The VertexAttachment</param>
            <param name="slot">Slot where the attachment belongs.</param>
            <param name="buffer">Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.</param>
        </member>
        <member name="T:Spine.Unity.SkeletonRenderer">
            <summary>Renders a skeleton.</summary>
        </member>
        <member name="E:Spine.Unity.SkeletonRenderer.OnPostProcessVertices">
            <summary> Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.</summary>
        </member>
        <member name="F:Spine.Unity.SkeletonRenderer.clearStateOnDisable">
            <summary>Clears the state when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.</summary>
        </member>
        <member name="M:Spine.Unity.SkeletonRenderer.AddSpineComponent``1(UnityEngine.GameObject,Spine.Unity.SkeletonDataAsset)">
            <summary>Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.</summary>
            <typeparam name="T">T should be SkeletonRenderer or any of its derived classes.</typeparam>
        </member>
        <member name="M:Spine.Unity.SkeletonRenderer.SetMeshSettings(Spine.Unity.MeshGenerator.Settings)">
            <summary>Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.</summary>
        </member>
        <member name="T:Spine.Unity.SkeletonUtilityBone">
            <summary>Sets a GameObject's transform to match a bone on a Spine skeleton.</summary>
        </member>
        <member name="F:Spine.Unity.SkeletonUtilityBone.boneName">
            <summary>If a bone isn't set, boneName is used to find the bone.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineSlot.#ctor(System.String,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineEvent.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineIkConstraint.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpinePathConstraint.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineTransformConstraint.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineSkin.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineAnimation.#ctor(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineAttachment.#ctor(System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.Boolean)" -->
        <member name="T:Spine.Unity.SpineAttachment.Hierarchy">
            <summary>
            A struct that represents 3 strings that help identify and locate an attachment in a skeleton.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Spine.Unity.SpineBone.#ctor(System.String,System.String,System.Boolean)" -->
        <member name="M:Spine.SkeletonExtensions.SetDrawOrderToSetupPose(Spine.Skeleton)">
            <summary>Resets the DrawOrder to the Setup Pose's draw order</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.SetColorToSetupPose(Spine.Slot)">
            <summary>Resets the color of a slot to Setup Pose value.</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.SetAttachmentToSetupPose(Spine.Slot)">
            <summary>Sets a slot's attachment to setup pose. If you have the slotIndex, Skeleton.SetSlotAttachmentToSetupPose is faster.</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.SetSlotAttachmentToSetupPose(Spine.Skeleton,System.Int32)">
            <summary>Resets the attachment of slot at a given slotIndex to setup pose. This is faster than Slot.SetAttachmentToSetupPose.</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.PoseWithAnimation(Spine.Skeleton,System.String,System.Single,System.Boolean)">
            <summary>
            Shortcut for posing a skeleton at a specific time. Time is in seconds. (frameNumber / 30f) will give you seconds.
            If you need to do this often, you should get the Animation object yourself using skeleton.data.FindAnimation. and call Apply on that.</summary>
            <param name = "skeleton">The skeleton to pose.</param>
            <param name="animationName">The name of the animation to use.</param>
            <param name = "time">The time of the pose within the animation.</param>
            <param name = "loop">Wraps the time around if it is longer than the duration of the animation.</param>
        </member>
        <member name="M:Spine.SkeletonExtensions.PoseSkeleton(Spine.Animation,Spine.Skeleton,System.Single,System.Boolean)">
            <summary>Pose a skeleton according to a given time in an animation.</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.SetKeyedItemsToSetupPose(Spine.Animation,Spine.Skeleton)">
            <summary>Resets Skeleton parts to Setup Pose according to a Spine.Animation's keyed items.</summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.FindNamesForSlot(Spine.Skin,System.String,Spine.SkeletonData,System.Collections.Generic.List{System.String})">
            <summary><see cref="!:Spine.Skin.FindNamesForSlot(int,List)"/></summary>
        </member>
        <member name="M:Spine.SkeletonExtensions.FindAttachmentsForSlot(Spine.Skin,System.String,Spine.SkeletonData,System.Collections.Generic.List{Spine.Attachment})">
            <summary><see cref="!:Spine.Skin.FindAttachmentsForSlot(int,List)"/></summary>
        </member>
        <member name="T:Water2DTool.FloatingObject">
            <summary>
            Abstract base class for anything that floats.
            </summary>
        </member>
        <member name="M:Water2DTool.FloatingObject2D.GetBoxVerticesWorldPosition">
            <summary>
            Calculates the global position of a BoxCollider2D vertices.
            </summary>
            <returns>Returns the global position of a box collider vertices.</returns>
        </member>
        <member name="M:Water2DTool.FloatingObject2D.GetPolygonVerticesWorldPosition">
            <summary>
            Generates an imaginary regular polygon based on the circle or sphere colliders center and radius.
            </summary>
            <returns>Returns the global position of a regular polygon vertices.</returns>
        </member>
        <member name="M:Water2DTool.FloatingObject2D.GetCapsuleVerticesWorldPosition">
            <summary>
            Generates an imaginary polygon based on a CapsuleCollider2D.
            </summary>
            <returns>Returns the global position of a polygon vertices.</returns>
        </member>
        <member name="M:Water2DTool.FloatingObject3D.GetBoxVerticesWorldPosition">
            <summary>
            Calculates the global position of a BoxCollider2D vertices.
            </summary>
            <returns>Returns the global position of a box collider vertices.</returns>
        </member>
        <member name="M:Water2DTool.FloatingObject3D.GetPolygonVerticesWorldPosition">
            <summary>
            Generates an imaginary regular polygon based on the circle or sphere colliders center and radius.
            </summary>
            <returns>Returns the world position of a regular polygon vertices.</returns>
        </member>
        <member name="M:Water2DTool.FloatingObject3D.GetCapsuleVerticesWorldPosition">
            <summary>
            Generates an imaginary polygon based on a CapsuleCollider center and radius.
            </summary>
            <returns>Returns the global position of a polygon vertices.</returns>
        </member>
        <member name="F:Water2DTool.ObstructionPolygon.handlesPosition">
            <summary>
            The local positions of the handles.
            </summary>
        </member>
        <member name="F:Water2DTool.ObstructionPolygon.handleScale">
            <summary>
            The scale of the handle gizmo.
            </summary>
        </member>
        <member name="M:Water2DTool.ObstructionPolygon.AddShapePoint(UnityEngine.Vector3)">
            <summary>
            Adds a point to the polygon shape.
            </summary>
            <param name="hP">Node local position.</param>
        </member>
        <member name="F:Water2DTool.RippleSource.prevPos">
            <summary>
            The position the ripple source had on the previous frame. 
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.currentPeriod">
            <summary>
            The time between ripples. 
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.timeCount">
            <summary>
            Time counter to determine when to generate a new ripple. 
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.radius">
            <summary>
            The initial radius of the ripple
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.strength">
            <summary>
            Ripple stregth
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.frequency">
            <summary>
            The number of ripples per second.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.minPeriod">
            <summary>
            Minimum value for a random number that is used to calculate how long to wait before generating a new ripple.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.maxPeriod">
            <summary>
            Maximum value for a random number that is used to calculate how long to wait before generating a new ripple.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.waterLineYAxisWorldPosition">
            <summary>
            Water line world position on the x Axis.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.active">
            <summary>
            Should this object generate ripples?.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.newRipple">
            <summary>
            Tells the Water2D_Ripple script that this object should generate a new ripple.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.handleScale">
            <summary>
            The scale of the handle gizmo.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.ignoreYAxisPosition">
            <summary>
            When set to true, the position on the Y axis of the ripple source is ignored.
            </summary>
        </member>
        <member name="F:Water2DTool.RippleSource.interactionDistance">
            <summary>
            If the distance from the water line to the ripple source is greater than the value of this field, ripples are not generated
            </summary>
        </member>
        <member name="F:Water2DTool.ShaderParam.WaterRippleID">
            <summary>
            The IDs of shader variables that store the center, radius and strength of a water ripple.
            </summary>
        </member>
        <member name="F:Water2DTool.ShaderParam.recObstVarIDs">
            <summary>
            The IDs of shader variables that store the positions of the 4 corners of a dynamic obstruction, in texture space.
            </summary>
        </member>
        <member name="F:Water2DTool.ShaderParam.waterWidthID">
            <summary>
            The IDs of shader variables that store the center and radius of a dynamic obstruction caused by a sphere collider, in texture space.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Mesh.Clear">
            <summary>
            Clears all verices, indices, uvs, and colors from this mesh, resets color to white.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Mesh.Build(UnityEngine.Mesh@,System.Boolean)">
            <summary>
            Clears out the mesh, fills in the data, and recalculates normals and bounds.
            </summary>
            <param name="mesh">An already existing mesh to fill out.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Mesh.GenerateTriangles(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates triangles from a list of vertices.
            </summary>
            <param name="xSegments">The number of horizontal segments.</param>
            <param name="ySegments">The number of vertical segments.</param>
            <param name="xVertices">The number of horizontal vertices.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Mesh.AddVertex(UnityEngine.Vector3,UnityEngine.Vector2,System.Boolean)">
            <summary>
            Adds a vertex to the meshVerts list and a UV point to the meshUVs list.
            </summary>
            <param name="vertexPoss">The position of a vertex.</param>
            <param name="aZ">The position of a vertex on the Z axis.</param>
            <param name="aUV">The UV coordinate of the current vertex.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Mesh.GetCurrentTriangleList(System.Int32)">
            <summary>
            Gets the current list of triangles.
            </summary>
            <param name="startIndex">An offset to start from.</param>
            <returns></returns>
        </member>
        <member name="T:Water2DTool.Water2D_PolygonClipping.Edge">
            <summary>
            This represents a line segment
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_PolygonClipping.GetIntersectedPolygon(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2[],System.Boolean@)">
            <summary>
            Calculates the intersection between a polygon and a line.
            </summary>
            <param name="subjectPoly">An Array of polygon points.</param>
            <param name="linePoints">Two points that form a line.</param>
            <returns>Returns an Array of polygon points.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_PolygonClipping.IsLeftOf(Water2DTool.Water2D_PolygonClipping.Edge,UnityEngine.Vector2)">
            <summary>
            Tells if the test point lies on the left side of the edge line
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_ObstructionType">
            <summary>
            Types of water obstruction.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_ObstructionType.None">
            <summary>
            No water obstruction is applied.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_ObstructionType.DynamicObstruction">
            <summary>
            Obstructions created by dynamic objects are applied to the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_ObstructionType.TextureObstruction">
            <summary>
            Texture obstructions are applied to the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_RippleSimulationUpdate.UpdateMethod">
            <summary>
            The ripple simulation runs in the Update method.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_RippleSimulationUpdate.FixedUpdateMethod">
            <summary>
            The ripple simulation runs in the Fixed Update method.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.shaderParam">
            <summary>
            Instance of ShaderParam class. Stores the IDs of different shader properties.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerOnExitRipplePos">
            <summary>
            World position of the ripple created when the player exits the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.tempRT">
            <summary>
            Temporary Render Texture.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.bufferCurrent">
            <summary>
            Stores the current state of the heightmap.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.bufferPrev">
            <summary>
            Stores the state of the heightmap it had on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple._finalHeightMap">
            <summary>
            Stores the final state of the heightmap for the current frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rtFormat">
            <summary>
            Render Texture format.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.renderTextureWidth">
            <summary>
            The width of the Render Textures used to store the height map.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.renderTextureHeight">
            <summary>
            The height of the Render Textures used to store the height map.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waterSimCount">
            <summary>
            A counter that is incremented by 1 every time the height map is processed through the shader that simulates ripple propagation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waterInteractions">
            <summary>
            The number of water interactions (ripples) that should be generated this frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rainTimeCounter">
            <summary>
            Used to determine when a new raindrop should generated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.heightMapTimeCounter">
            <summary>
            Used to determine when the height map should be processed through the shader that simulates ripple propagation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.interactionsTimeCounter">
            <summary>
            Used to determine when the interaction with the water should be updated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.addInteraction">
            <summary>
            Should a ripple be generated on this frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.boxColObstList">
            <summary>
            List that stores the box colliders that generate dynamic obstructions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.sphereColObstList">
            <summary>
            List that stores the sphere colliders that generate dynamic obstructions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.kinematicRippleSourcesList">
            <summary>
            List that stores references to RippleSource scripts that are found on kinematic objects.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.heightMapMaterial">
            <summary>
            Material that uses the shader that generates ripples and simulates ripple propagation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.heightMapMaterialTexObst">
            <summary>
            Material that uses the shader that generates ripples and simulates ripple propagation.
            Supports texture obstructions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.heightMapMaterialDynObst">
            <summary>
            Material that uses the shader that generates ripples and simulates ripple propagation.
            Supports dynamic obstructions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.bCubicResamplingMat">
            <summary>
            Material that uses a shader that resamples a texture and applies a smoothing effect to it.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.ambientWavesMat">
            <summary>
            Material that uses a shader that adds sine wave patterns to the final state of the current frame height map.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.water2DTool">
            <summary>
            Reference to this object's Water2D_Tool component.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.water2DSim">
            <summary>
            Reference to this object's Water2D_Simulation component.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.xyAxisScale">
            <summary>
            Used to remove the stretching effect when the width and length of the water are not equal.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.leftHandleWorldPos">
            <summary>
            World position of the left haldle.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.prevPos">
            <summary>
            The position of the water object on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.transform">
            <summary>
            The Transform component of the water object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.camTransform">
            <summary>
            Main camera Transform component.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.frontMeshRend">
            <summary>
            The renderer component of the front mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.topMeshRend">
            <summary>
            The renderer component of the top mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rWaterWidth">
            <summary>
            1f / x. Instead of dividing a value by the width of the water we multiply that value by it reverse.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rWaterLength">
            <summary>
            1f / x. Instead of dividing a value by the length of the water we multiply that value by it reverse.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.prevCamPosRelativeToWaterLine">
            <summary>
            Used to find where was the camera on the previous frame relative to the water line.
            Holds the value of 1 if the camera is above the water line, -1 if below.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.interactionsTimeStep">
            <summary>
            The time between 2 consecutive interaction updates.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerOnExitRipple">
            <summary>
            Should a ripple be generated when the player exits the water?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitude1">
            <summary>
            Sine wave amplitude. The bigger the value the higher the wave top will be.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitude2">
            <summary>
            Sine wave amplitude. The bigger the value the higher the wave top will be.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitude3">
            <summary>
            Sine wave amplitude. The bigger the value the higher the wave top will be.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waveLength1">
            <summary>
            The distance between 2 consecutive points of a sine wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waveLength2">
            <summary>
            The distance between 2 consecutive points of a sine wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waveLength3">
            <summary>
            The distance between 2 consecutive points of a sine wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.phaseOffset1">
            <summary>
            Sine wave phase offset. The bigger the value of the phase offset the faster the waves move to the left (right).*/
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.phaseOffset2">
            <summary>
            Sine wave phase offset. The bigger the value of the phase offset the faster the waves move to the left (right).
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.phaseOffset3">
            <summary>
            Sine wave phase offset. The bigger the value of the phase offset the faster the waves move to the left (right).
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitudeFadeStart">
            <summary>
            Amplitude fade start point.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitudeFadeEnd">
            <summary>
            Amplitude fade end point.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.ambientWaves">
            <summary>
            Enables sine waves.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.amplitudeZAxisFade">
            <summary>
            Enables sine wave amplitude on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.heightUpdateMapTimeStep">
            <summary>
            The time between 2 consecutive height map updates.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.bicubicResampling">
            <summary>
            Should a smoothing effect be applied to the heightmap.?
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rippleSourcesList">
            <summary>
            List that stores references to RippleSource scripts.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rippleSources">
            <summary>
            Enables the ripple sources option.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rippleWaterFPSCap">
            <summary>
            Determines how many times per second should the height map be processed through the shader that simulates ripple propagation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rainDrops">
            <summary>
            Enables rain.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rainDropRadius">
            <summary>
            The radius of a rain drop in Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rainDropStrength">
            <summary>
            The strength of a rain drop.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rainDropFrequency">
            <summary>
            The number of water drops that should fall in a second.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.waterDamping">
            <summary>
            Damping parameter for the water propagation simulation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.mouseRadius">
            <summary>
            The radius of the ripple created by the mouse arrow, in Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.mouseStregth">
            <summary>
            The strength of the ripple created by the mouse arrow.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.rtPixelsToUnits">
            <summary>
            The number of Render Texture pixels that should fit in 1 unit of Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.obstructionTexture">
            <summary>
            Texture with water obstructions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.mouseInteraction">
            <summary>
            Enables the ability to interact with the water using the mouse arrow.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerRippleRadius">
            <summary>
            The radius of the ripple created by the player.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerRippleStrength">
            <summary>
            The strength of the ripple created by the player.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerVelocityFilter">
            <summary>
            If the player has a velocity lower than that of the value of this field than no ripples will be generated by him.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.playerRippleXOffset">
            <summary>
            Offsets the position of the ripple created by the player.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.objectRippleRadius">
            <summary>
            The radius of the ripple created by objects that have the script RippleSource attached to them.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.objectRippleStrength">
            <summary>
            The strength of the ripple created by objects that have the script RippleSource attached to them.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.objectVelocityFilter">
            <summary>
            Used to determine if a dynamic object can generate ripples?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.objectXAxisRippleOffset">
            <summary>
            Offsets the ripple  position on the X axis based on the width of the coliders bounding box. A value of 0 means that the ripple will be generated at the center of the collider. 
            A value of 0.5f means that the ripple will be positioned at the left or right edge of the colliders bounding box.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.obstructionLayers">
            <summary>
            Layer mask.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.drawBothSides">
            <summary>
            When the camera is below the waterline, should both sides of the top mesh be drawn?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.strengthScale">
            <summary>
            Used to scale up or down the strength of the ripples created by dynamic objects when the Abs value
            of the velocity on the Y axis is greater than the Abs value of the velocity on the X axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Ripple.fixedRadius">
            <summary>
            When true, the radius of the ripple created by dynamic objects will be the same for all objects. 
            When false the radius of the ripple depends on size of the collider of that object.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.RippleWaterSimulationUpdate">
            <summary>
            Runs the ripple water simulation in the Update method.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.RippleWaterSimulationFixedUpdate">
            <summary>
            Runs the ripple water simulation in the FixedUpdate method.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.UpdateHeightMapWithWaterInteractions">
            <summary>
            Runs the current height map through a shader that adds ripples caused by rain or by objects.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.UpdateHeightMap">
            <summary>
            Runs the current height map through a shader pass that simulates the propagation of ripples.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.TopMeshCulling">
            <summary>
            Controls which sides of polygons should be culled (not drawn). 
            Which side should be culled is decided based on the position of
            the camera relative to the water line position on the Y axis.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.SetTopMeshCulling">
            <summary>
            Sets top mesh culling to Front, Back or Off. 
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.SetWaterLinePosition">
            <summary>
            Tells the ripple sources the global position of the water line for the current object. 
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.AddRain">
            <summary>
            Adds rain ripples. 
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.UpdateRippleShaderParameters">
            <summary>
            Updates some variables used by the shader responsible for generating the heightmap.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.UpdateWaterInteractions">
            <summary>
            Calculates the properties of the ripples caused by objects.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.DynamicObjectsInteraction">
            <summary>
            Calculates the properties of the ripples caused by dynamic objects.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.PhysicsBasedCharacterController(System.Int32,UnityEngine.Vector3,System.Single)">
            <summary>
            Calculates the properties of the ripples caused by Player.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <param name="vel"> Player velocity.</param>
            <param name="scale">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.RaycastBasedCharacterController(System.Int32)">
            <summary>
            Calculates the properties of the ripples caused by Player.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.CanGenerateRipple(UnityEngine.Vector3,System.Int32,System.Single@)">
            <summary>
            Checks if an object is moving or not.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.AddRippleAtPosition(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Generates a ripple at the specified position. 
            If the specified position is not inside the X, Z bounding box of the water, no ripple will be generated.
            </summary>
            <param name="pos">World space postion of the ripple. Only the X a Z values are used</param>
            <param name="radius">The radius of the ripple in Unity units.</param>
            <param name="strength">The strength of the ripple.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.ObjectInteraction(System.Int32)">
            <summary>
            Calculates the properties of the ripples caused by a dynamic object.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.RippleSourcesInteraction">
            <summary>
            Calculates the properties of the ripples caused by objects that have the RippleSource script attached to them.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.IsInside(UnityEngine.Vector3)">
            <summary>
            Checks if a point is inside the waters bound. The position of the point on the Y axis is ignored. 
            </summary>
            <param name="point">Point in world space coordinates.</param>
            <returns> Returns true if the point inside the waters bounds. False if not inside.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.MouseOnWater">
            <summary>
            Calculates the properties of the ripples caused by the mouse arrow.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.ResetWaterInteractionParameters">
            <summary>
            Resets the variables used by the shader to add new ripples the height map.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.GetColliderTopPoint(Water2DTool.FloatingObject)">
            <summary>
            Finds a colliders bounding box top point position on the Y axis.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.GetUVFromPosition(UnityEngine.Vector3)">
            <summary>
            Converts a world space position to a texture position.
            </summary>
            <param name="worldPos"> A Point in world space. </param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.WorldSpaceValueToUV(System.Single)">
            <summary>
            Converts a world space radius to a texture radius.
            </summary>
            <param name="radius"> A world space radius value </param>
            <returns> Returns a UV space value.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.AddRippleToShader(System.Int32,UnityEngine.Vector2,System.Single,System.Single)">
            <summary>
            Stores the properties of a water ripple in a shader variable.
            </summary>
            <param name="index"> The index of the variable where the ripple properties should be stored. </param>
            <param name="uvPos"> The center position of the ripple in UV space. </param>
            <param name="uvRadius"> The ripple radius in UV space. </param>
            <param name="strength"> The ripple strength. </param>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.UpdateDynamicObstructions">
            <summary>
            Udates the varibles that store the dynamic obstructions.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.GetCicleObstruction(UnityEngine.SphereCollider)">
            <summary>
            Calculates the center and radius in texture space for a sphere collider.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.GetRectangleObstruction(UnityEngine.Collider)">
            <summary>
            Calculates rectangles 4 corners position in texture space.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.SetAmbientWavesShaderParameters">
            <summary>
            Sets the values for the variables used to generate sine waves.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Ripple.IsInLayerMask(System.Int32,System.Int32)">
            <summary>
            Checks whether the current object layer is enabled on a layer mask.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_AnimationMethod">
            <summary>
            Describes how the water handles should be animated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_AnimationMethod.None">
            <summary>
            The water will not be animated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_AnimationMethod.Follow">
            <summary>
            The animated handle follows the movement of a referenced object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_AnimationMethod.Snap">
            <summary>
            The animated handle's global position is set to that of a referenced object.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_FlowDirection">
            <summary>
            Describes the direction of the water flow.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_FlowDirection.Up">
            <summary>
            The water flow will push the objects up.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_FlowDirection.Down">
            <summary>
            The water flow will push the objects down.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_FlowDirection.Left">
            <summary>
            The water flow will push the objects to the left.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_FlowDirection.Right">
            <summary>
            The water flow will push the objects to the right.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_ClippingMethod">
            <summary>
            Determines which clipping method will be used to calculate the shape of the polygon that is below the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_ClippingMethod.Simple">
            <summary>
            Uses the Sutherland Hodgman polygon clipping algorithm. This is the cheapest option in terms of
            performance because the clipping polygon is always a horizontal line.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_ClippingMethod.Complex">
            <summary>
            Uses the clipper library. This option is best to use when you want the objects to better react to water waves.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_BuoyantForceMode">
            <summary>
            Describes how the Buoyant Force applied to a floating object, should be simulated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_BuoyantForceMode.None">
            <summary>
            No buoyancy will be applied to objects.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_BuoyantForceMode.PhysicsBased">
            <summary>
            A physics based Buoyant Force will be applied to a floating object. This method takes into
            account the mass of the object and it's shape. Use this for a more realistic simulation
            of Buoyant Forces. It's a little more expensive then the Linear.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_BuoyantForceMode.Linear">
            <summary>
            A linear Buoyant Force will be applied to a floating object. This method does not take into
            account the objects shape.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_SurfaceWaves">
            <summary>
            Describes how surface waves like the one created by the wind should be generated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_SurfaceWaves.None">
            <summary>
            No surface waves will be generated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_SurfaceWaves.RandomSplashes">
            <summary>
            Generates small random water splashes.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_SurfaceWaves.SineWaves">
            <summary>
            Sine waves with random values are used to simulate waves.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_SineWaves">
            <summary>
            Determines the number of sine waves.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_SineWaves.SingleSineWave">
            <summary>
            A single sine wave will be used to change the velocity of the survace vertices.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_SineWaves.MultipleSineWaves">
            <summary>
            Multiple sine waves will be used to change the velocity of the survace vertices.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_Type">
            <summary>
            Describes the type of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Type.Dynamic">
            <summary>
            The water will react to objects and will influence their position.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Type.Decorative">
            <summary>
            The water won't react to objects and won't influence their position, but can be animated.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_CharacterControllerType">
            <summary>
            Describes the character controller type.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_CharacterControllerType.PhysicsBased">
            <summary>
            The character controller uses the Unity Physics engine to move the player. The Player is a dynamic object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_CharacterControllerType.RaycastBased">
            <summary>
            The character controller uses Raycasts to determine and control the player position. The Player is a kinematic object.
            </summary>
        </member>
        <member name="T:Water2DTool.Water2D_CollisionDetectionMode">
            <summary>
            Methods used to determine if a surface vertex velocity should be changed by and object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_CollisionDetectionMode.RaycastBased">
            <summary>
            Method used to determine if a surface vertex velocity should be changed by and object.
            When a vertex is inside the bounding box of an objects collider a raycast is performed to find if that vertex is actually inside the collider.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_CollisionDetectionMode.BoundsBased">
            <summary>
            Method used to determine if a surface vertex velocity should be changed by and object
            A surface vertex velocity can be influenced by an object if the vertex is inside the bounding box of that objects collider.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.velocities">
            <summary>
            Surface vertices velocities.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.vertYOffsets">
            <summary>
            Surface vertices cccelerations.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.sineY">
            <summary>
            List of Y values created from the overlapping of a number of sine waves.
            This values are used to change the velocity of the surface vertices and simulate idle waves.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.frontMeshVertices">
            <summary>
            Water mesh vertices.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topMeshVertices">
            <summary>
            Water mesh vertices.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.frontMeshUVs">
            <summary>
            Water mesh UVs.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topMeshUVs">
            <summary>
            Water mesh UVs.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.phase">
            <summary>
            A phase to apply to each sine wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.surfaceVertsCount">
            <summary>
            The number of vertices the water surface (top edge of the water) has.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterLineCurrentLocalPos">
            <summary>
            The local position of the water line on the Y axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterLinePreviousLocalPos">
            <summary>
            The local position of the water line on the Y axis at the start of the current frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.forceFactor">
            <summary>
            The scale of the force that should be applied to an object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.forcePosition">
            <summary>
            The position where the upwards force should be applied to an object submerged in the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.upLift">
            <summary>
            The upward force that should be applied to an object submerged in the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.defaultWaterHeight">
            <summary>
            The default water height. This value is set in the Start method.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.defaultWaterArea">
            <summary>
            The default water area. This value is set in the Start method.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.prevTopEdgeYPos">
            <summary>
            The position on the Y axis the TopEdge object had on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.prevBottomEdgeYPos">
            <summary>
            The position on the Y axis the BottomEdge object had on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.prevLeftEdgeXPos">
            <summary>
            The position on the X axis the LeftEdge object had on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.prevRightEdgeXPos">
            <summary>
            The position on the X axis the RightEdge object had on the previous frame.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.recreateWaterMesh">
            <summary>
            Used to determine if the water mesh should be recreated from scratch.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.updateWaterHeight">
            <summary>
            Used to determine if the water mesh height should be updated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterLineYPosOffset">
            <summary>
            The amount by which the water height should be increased after all the calculations are done.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.prevDefaultWaterAreaOffset">
            <summary>
            The value that defaultWaterAreaOffset had at the end of the previous frame
            (has at the start of the current frame).
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.frontMeshFilter">
            <summary>
            Water Mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topMeshFilter">
            <summary>
            Water Mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.water2D">
            <summary>
            Water2D component.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.makeSplash">
            <summary>
            Used to generate a random splash.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.onTriggerPlayerDetected">
            <summary>
            The variable is set to true when a collider with the tag "Player"
            is found by the OnTriggerEnter2D method.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.area">
            <summary>
            The area of the polygon segment that is below the waterline.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.displacedMass">
            <summary>
            The mass of the water that has the area equal to the area of the polygon segment that is below the waterline.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.precisionFactor">
            <summary>
            When animating an edge of the water, Water2D compares the difference between the current position
            of a referenced object and the one it had on the previous frame to the precisionFactor.
            If the difference is bigger than the precisionFactor, than the object moved on the current frame
            from the position it had on the previous frame. Comparing the position the object has on the current
            frame to the one that it had on the previous frame directly is not a good idea as Unity may round the
            numbers differently even if the reference object didn't change its position. Do not change the value of
            this field if you are not sure what it does.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.leftHandleGlobalPos">
            <summary>
            The global position of the left handle.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterLinePoints">
            <summary>
            A list of points that form the water line.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.scaleFactor">
            <summary>
            It is used to convert float numbers to int and back.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.rScaleFactor">
            <summary>
            1 / x. The reverse of scaleFactor value.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.updateMeshDate">
            <summary>
            Should mesh vertex and UV date be updated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.polygonClipping">
            <summary>
            Instance the polygon clipping class.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.boxVertices">
            <summary>
            Stores the positions of the 4 corners of a box.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.submergedPolygon">
            <summary>
            List of points that describe the segment of a collider that is below the water line.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.clipPolygon">
            <summary>
            2 points that form a horizontal line.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.clipper">
            <summary>
            Reference to the clipper library.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.intersectionPolygon">
            <summary>
            List of points that describe an intersaction poligon.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.intersectionPolygons">
            <summary>
            List of points that describe multiple intersaction poligons.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.linePoints">
            <summary>
            2 points that form a horizontal line.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.hit2D">
            <summary>
            Array that stores the results of a RaycastNonAlloc.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.hit3D">
            <summary>
            Array that stores the results of a OverlapSphereNonAlloc.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.tiling">
            <summary>
            Should the water be tiled?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.hasRippleScript">
            <summary>
            Is the Water2D_Ripple script attached to this object?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.yAxisOffset">
            <summary>
            How much should the top mesh up or down on the Y axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.frontMeshRend">
            <summary>
            The renderer component of the front mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topMeshRend">
            <summary>
            The renderer component of the top mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.transform">
            <summary>
            The Transform component of the water object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.floatingObjects">
            <summary>
            List of floating objects
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerOnExitVelocity">
            <summary>
            The velocity that is applied to a surface vertex when the player exits the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerOnExitRipple">
            <summary>
            Should the player generate a water ripple when it exits the water?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerOnExitPSAndSound">
            <summary>
            Should a particle system be instantiated and a sound effect played the player exits the water?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.sineAmplitudes">
            <summary>
            List of sine wave amplitudes.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.sineStretches">
            <summary>
            The amount by which a particular sine wave is stretched.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.phaseOffset">
            <summary>
            Sine wave phase offset.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.defaultWaterAreaOffset">
            <summary>
            This is the variable that should be changed if animateWaterArea is set to true.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.sineWaves">
            <summary>
            The number of Sine waves.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.springConstant">
            <summary>
            The spring constant.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.damping">
            <summary>
            The damping applied to the surface vertices velocities.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.spread">
            <summary>
            It controls how fast the waves spread.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.floatHeight">
            <summary>
            Determines how much force should be applied to an object submerged in the water. A value of 3 means
            that 3m under the water, the force applied to an object will be 2 times greater than the force applied
            at the surface of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.bounceDamping">
            <summary>
            A bounce damping for the object bounce.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.forcePositionOffset">
            <summary>
            Offsets the position where the upwards force should be applied to an object submerged in the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.collisionVelocityScale">
            <summary>
            Limits the velocity on the Y axis that is applied to a waterline vertex.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topEdge">
            <summary>
            Used to animate the position of the water line on the Y axis. Assign an animated
            object to this field if you want to increase or decrease the water level.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.bottomEdge">
            <summary>
            Used to animate the position of the water bottom on the Y axis. Will also affect the waterline position.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.leftEdge">
            <summary>
            Used to animate the position of the left edge of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.rightEdge">
            <summary>
            Used to animate the position of the right edge of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.particleS">
            <summary>
            A particle system prefab for water splash effect.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.constantWaterArea">
            <summary>
            When set to true will force the default water area to be constant. So if the water width
            decreases (increases) the water height will increase (decrease).
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterDisplacement">
            <summary>
            When set to true the objects that are submerged in the water will make the water rise.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.animateWaterArea">
            <summary>
            Set this to true if you want to animate the default water area.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waveSpeed">
            <summary>
            Controls the water wave propagation speed.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.velocityFilter">
            <summary>
            Objects with downwards velocity greater than the value of velocityFilter won't create waves.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterDensity">
            <summary>
            The density of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.polygonCorners">
            <summary>
            The number of vertices a regular polygon should have.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxDrag">
            <summary>
            The maximum drag that should be applied to a colliders edge.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxLift">
            <summary>
            The maximum lift that should be applied to a colliders edge.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.dragCoefficient">
            <summary>
            Drag Coefficient.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.liftCoefficient">
            <summary>
            Lift Coefficient.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.timeStep">
            <summary>
            How often should a random splash be generated.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxAmplitude">
            <summary>
            The max value of a random amplitude.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.minAmplitude">
            <summary>
            The min value of a random amplitude.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxStretch">
            <summary>
            The max value of a random stretch.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.minStretch">
            <summary>
            The min value of a random stretch.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxPhaseOffset">
            <summary>
            The max value of a random phase offset.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.minPhaseOffset">
            <summary>
            The min value of a random phase offset.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.maxVelocity">
            <summary>
            The max value of a random velocity.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.minVelocity">
            <summary>
            The min value of a random velocity.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.forceScale">
            <summary>
            The force scale used when Buoyant Force Mode is set to Linear. A value of 1f will make the object with
            the mass of 1kg float at the surface of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.liniarBFDragCoefficient">
            <summary>
            The drag coefficient used when Buoyant Force Mode is set to Linear.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.liniarBFAbgularDragCoefficient">
            <summary>
            The angular drag coefficient used when Buoyant Force Mode is set to Linear.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.interactionRegion">
            <summary>
            The bottom region of a colliders bounding box that can affect the velocity of a vertex.
            We use this value to limit the ability of the objects with big bounding boxes to affect
            the velocity of the surface vertices. If we don't do this, a long object that falls down
            slowly will push the water down for a longer period of time and produce a not very realistic simulation.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterLineCurrentWorldPos">
            <summary>
            The global position of the water line on the Y axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.splashSound">
            <summary>
            Splash sound effect.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerBoundingBoxSize">
            <summary>
            The size for the players bounding box.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerBoundingBoxCenter">
            <summary>
            By default the center of the bounding box will be the transform.position of the
            object. Use this variable to offset the players bounding box center.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerBuoyantForceScale">
            <summary>
            Use this variable to set the scale for the buoyant force that is applied to
            the object with the "Player" tag.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.showPolygon">
            <summary>
            When enabled will show in the Scene View the shape of the polygon that is below the waterline.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.showForces">
            <summary>
            When enabled will show in the Scene View the velocity direction, drag direction,
            lift direction and the normal of a leading edge.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.neighborVertVelocityScale">
            <summary>
            Will scale down (up) the velocity that is applied to the neighbor vertices when RandomWave method is called.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.sineWaveVelocityScale">
            <summary>
            Will scale down (up) the velocity that is applied to a vertex from a sine wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.overlapSphereRadius">
            <summary>
            The radius of a sphere that will be used to check if there is a collider near a surface vertex.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.springSimulation">
            <summary>
            Should the spring simulation be enabled?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.topEdgeYOffset">
            <summary>
            The offset on the Y axis from the position of a referenced object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.bottomEdgeYOffset">
            <summary>
            The offset on the Y axis from the position of a referenced object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.leftEdgeXOffset">
            <summary>
            The offset on the X axis from the position of a referenced object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.rightEdgeXOffset">
            <summary>
            The offset on the X axis from the position of a referenced object.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.particleSystemPosOffset">
            <summary>
            Offsets the position where the particle systems are created on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.particleSystemSortingLayerName">
            <summary>
            The sorting layer name for the particle system.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.particleSystemOrderInLayer">
            <summary>
            The order in layer for the particle system.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.meshSegmentsPerWaterLineSegment">
            <summary>
            The number of vertical mesh segments that should fit in a water line segment.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterFlow">
            <summary>
            Should the water flow be enabled?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.flowAngle">
            <summary>
            The angle of the water flow. This value controls the direction of the water flow.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waterFlowForce">
            <summary>
            The force of the water flow.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.useAngles">
            <summary>
            Should the direction be controlled using an angle value specified by the developer?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waveAmplitude">
            <summary>
            The amplitude of a sine wave. This variable controls the height of the sine wave
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.waveStretch">
            <summary>
            The sine wave stretch. The bigger the value of the stretch the more compact the waves are.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.wavePhaseOffset">
            <summary>
            Sine wave phase offset. The bigger the value of the phase offset, the faster the waves move to the left (right).
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.randomValues">
            <summary>
            When enabled the sine waves amplitude, stretch and phase offset will be generated randomaly at the start of the game.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.particleSystemSorting">
            <summary>
            Should the particle system sorting layer and order in layer be set when it is instantiated?
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.rippleWidth">
            <summary>
            The initial width of the water wave.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.playerOnEnterVelocity">
            <summary>
            The velocity that will be applied to the surface vertices when the player enters the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.collisionLayers">
            <summary>
            Layer Mask that tells the water which colliders should be ignored.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.raycastDistance">
            <summary>
            How far to the left and right from a vertex world position should we look for a collider.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.interactionTime">
            <summary>
            How many seconds after an object interacted with the water surface and generated a ripple, should the spring simulation stop updating.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.interactionTimeCount">
            <summary>
            The time interval since the last time an object interacted with the surface of the water and generated a ripple
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Simulation.water2DRipple">
            <summary>
            Reference to the Water2D_Ripple component of this object. 
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ColliderExists(System.Int32)">
            <summary>
            Checks if a collider exists or not. Destroys it if it's missing.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateSineVariables">
            <summary>
            Generate a list of random values for the sine amplitudes, stretches and phase offsets.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.Buoyancy">
            <summary>
            Applies buoyancy to the objects in the water based on the buoyancy settings.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.WaterDisplacement">
            <summary>
            Calculates the height of the displaced water when an object is submerged in the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ApplyWaterDisplacement(System.Int32)">
            <summary>
            Calculates the height of the displaced water when an object is submerged in the water.
            </summary>
            <param name="oIndex">The index of a floating object.</param>
            <remarks>
            It's not 100% accurate.
            </remarks>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.RandomWave">
            <summary>
            Creates small waves in random places.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.SineWaves">
            <summary>
            Updates the Y values of the sine waves for each surface vertex and changes the velocities.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.OverlapSineWaves(System.Single)">
            <summary>
            Overlaps multiple sine waves to achieve a more realistic water wave simulation.
            </summary>
            <param name="x">The position of a vertex on the X axis.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ShaderAnimation">
            <summary>
            Animates the top edge of the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.WaterAnimation">
            <summary>
            Animates the top, bottom, left and right edges of the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.WaterMesh">
            <summary>
            Checks if the water Mesh height must be updated or the mesh must be recreated from scratch.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.UpdateWaterHeight">
            <summary>
            Updates the height of the water Mesh and recalculates the UV's for the bottom vertices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Water2DTool.Water2D_Simulation.RecreateWaterMesh" -->
        <!-- Badly formed XML comment ignored for member "M:Water2DTool.Water2D_Simulation.CreateWaterLinePoints" -->
        <member name="M:Water2DTool.Water2D_Simulation.UpdateTopLeftRightHandles">
            <summary>
            Updates the position of the Top, Right and Left handles.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.WaterWaves">
            <summary>
            Simulates water waves generated by falling objects.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.UpdateWaterLinePoints">
            <summary>
            Updates the position of the water line points. This are the points
            that will be used to define a clipping polygon.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GetVertMinMaxIndex(UnityEngine.Vector3,System.Single,System.Int32@,System.Int32@)">
            <summary>
            Generates a surface wave at a given position.
            </summary>
            <param name="worldPos">World position of a collider.</param>
            <param name="width">The width of colliders bounding box.</param>
            <param name="minIndex">The index of the surface vertex that is closest to the left edge of the bounding box of a collider.</param>
            <param name="maxIndex">The index of the surface vertex that is closest to the right edge of the bounding box of a collider.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateRippleAtPosition(UnityEngine.Vector3,System.Single,System.Single,System.Boolean)">
            <summary>
            Generates a surface wave at a given position.
            </summary>
            <param name="rippleWorldPos">World position of where the center of the new surface wave will be.</param>
            <param name="rippleWidth">The width of the wave.</param>
            <param name="vertexVelocity">The velocity a wate line vertex will receive.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateWaterWaves(System.Int32)">
            <summary>
            Simulates water waves generated by falling objects.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateRippleBasedOnRaycast(System.Int32,System.Int32,System.Int32)">
            <summary>
            Finds the vertices that are inside a collider and updates their velocities. Generates Particles system and sound effect. 
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <param name="minIndex">The index of the surface vertex that is closest to the left edge of the bounding box of a collider.</param>
            <param name="maxIndex">The index of the surface vertex that is closest to the right edge of the bounding box of a collider.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateRippleBasedOnPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Finds the vertices that are inside a colliders bounding box and updates their velocities. Generates Particles system and sound effect. 
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <param name="minIndex">The index of the surface vertex that is closest to the left edge of the bounding box of a collider.</param>
            <param name="maxIndex">The index of the surface vertex that is closest to the right edge of the bounding box of a collider.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.InstantiateParticleSystem(System.Int32,System.Single,UnityEngine.Vector3)">
            <summary>
            Instantiates a new particle system. 
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <param name="yAxisPos">Position on the Y axis where the particle system will be instantiated.</param>
            <param name="pos">Position of the object that triggered this particle system.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.PlaySoundEffect(UnityEngine.Vector3,System.Int32)">
            <summary>
            Playes a sound effect. 
            </summary>
            <param name="pos">Position of the object that triggered this sound effect.</param>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.CanGenerateRipples(System.Int32)">
            <summary>
            Checks if an object meets all the necessary requirements for him to be able to interact with the surface of the water.. 
            </summary> object
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.UpdateVertsPosition">
            <summary>
            Updates the position of the surface vertices.
            </summary>
            <remarks>
            Based on:
            http://gamedevelopment.tutsplus.com/tutorials/make-a-splash-with-2d-water-effects--gamedev-236
            </remarks>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.PhysicsBasedBuoyantForce">
            <summary>
            Applies a buoyant force, drag and lift to an object submerged in the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ApplyPhysicsBasedBuoyantForce(System.Int32)">
            <summary>
            Applies a buoyant force, drag and lift to an object submerged in the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ApplyForcesToObject(System.Collections.Generic.List{UnityEngine.Vector2},UnityEngine.Vector2[],System.Int32)">
            <summary>
            Applies a buoyant force, drag and lift to an object submerged in the water.
            </summary>
            <param name="subjPoly"> The polygon of the object in the water.</param>
            <param name="clipPoly"> The clipping polygon.</param>
            <param name="oIndex">The index of an object stored in the floatingObjects list object.</param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.CalculateIntersectionPolygons(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Applies a buoyant force, drag and lift to an object submerged in the water.
            </summary>
            <param name="subjectPoly"> The polygon of the object in the water.</param>
            <param name="minIndex"> The min index for a value in the "waterLinePoints" list. </param>
            <param name="maxIndex"> The max index for a value in the "waterLinePoints" list. </param>
            <param name="isIntersecting"> Are the subject and clipping polygon intersecting?. </param>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GetPlayerBoudingBoxVerticesGlobalPos(System.Int32)">
            <summary>
            Calculates the world position for the players bounding box vertices.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <returns>Returns the world position of a bounding box vertices.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.Cross(System.Single,UnityEngine.Vector2)">
            <summary>
            Performs the cross product on a vector and a scalar.
            </summary>
            <param name="a">A scalar value.</param>
            <param name="b">A 2D vector.</param>
            <returns>Returns new 2D vector.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ApplyPhysicsForces(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Applies a buoyant force, drag and lift to an object submerged in the water.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <param name="intersectionPolygon">List of a polygon vertices.</param>
            <remarks>
            Based on:
            http://www.iforce2d.net/b2dtut/buoyancy
            </remarks>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GetPolygonAreaAndCentroid(System.Collections.Generic.List{UnityEngine.Vector2},System.Single@)">
            <summary>
            Calculates the area of a polygon and its centroid. The vertices order must be counterclockwise.
            </summary>
            <param name="polygonVertices">The polygon for which to calculate the area and the centroid.</param>
            <param name="polygonArea">Link to a variable.</param>
            <returns>Returns the polygon centroid.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GetPolygonArea(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Calculates the area of a polygon. The vertices order must be counterclockwise.
            </summary>
            <param name="polygonVertices">Polygon vertices.</param>
            <returns>Returns the polygon area.</returns>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.LinearBuoyantForce">
            <summary>
            Applies an upward force, a simple drag and torque on the objects that are in the water.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ApplyLinearBuoyantForce(System.Int32)">
            <summary>
            Applies an upward force, a simple drag and torque on the objects that are in the water.
            </summary>
            <param name="oIndex">The index of an object stored in the floatingObjects list.</param>
            <remarks>
            Based on:
            https://www.youtube.com/watch?v=mDtnT5fh7Ek
            </remarks>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.UpdateVariables">
            <summary>
            Updates different variables after the water mesh was recreated from scratch.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.GenerateParticleSystemAndSoundEffect(UnityEngine.Vector3)">
            <summary>
            Instantiates a particle system and plays a sound effect
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.ResetVariables">
            <summary>
            Used for resetting some variables after the mesh is recreated. Not part of the Water 2D Tool main code.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Simulation.OnTriggerExitPlayer(UnityEngine.Vector3)">
            <summary>
            Instantiates a particle system and plays a sound effect when the player exits the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.frontMeshRend">
            <summary>
            The renderer component of the front mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.rtPixelSize">
            <summary>
            The width and height of a render texture pixels in Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.ripple">
            <summary>
            Reference to the Water2D_Ripple component.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.checkComponentReference">
            <summary>
            Prevents the code responsible for the creation of the Mesh component from being called during play mode.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.rRTWidthInWorldSpace">
            <summary>
            1 /x . The reverse value of the render texture width in Unity units.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.rRTHeightInWorldSpace">
            <summary>
            1 /x . The reverse value of the render texture height in Unity units.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.boundsAndNormals">
            <summary>
            Should the bounds and normal be recalculated?.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.parentMesh">
            <summary>
            Reference to the front mesh of the water. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.childMesh">
            <summary>
            Reference to the top mesh of the water. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.parentDMesh">
            <summary>
            Water2D_Mesh instance used for the front mesh. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.childDMesh">
            <summary>
            Water2D_Mesh instance used for the top mesh. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.zVertDistance">
            <summary>
            Water2D_Mesh property for the front mesh. 
            </summary>
            <summary>
            The distance on between 2 vertices on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.xVertDistance">
            <summary>
            The width of a horizontal segment. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.ySegments">
            <summary>
            The number of vertical segments. This value must not be changed.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.transform">
            <summary>
            The Transform component of the water object.
            </summary>
        </member>
        <member name="P:Water2DTool.Water2D_Tool.ParentDMesh">
            <summary>
            Water2D_Mesh property for the front mesh. 
            </summary>
        </member>
        <member name="P:Water2DTool.Water2D_Tool.ChildDMesh">
            <summary>
            Water2D_Mesh property for the top mesh. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.unitsPerUV">
            <summary>
            The max width and height the water can have without tiling. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.unitsPerUV2">
            <summary>
            The max width and height the water can have without tiling. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.rUnitsPerUV">
            <summary>
            1 / x. The reverse value of unitsPerUV. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.rUnitsPerUV2">
            <summary>
            1 / x. The reverse value of unitsPerUV2. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.xSegments">
            <summary>
            The number of horizontal segments. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.zSegments">
            <summary>
            The number of segments on the Z axis. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.width">
            <summary>
            The water width. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.height">
            <summary>
            The water height. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.length">
            <summary>
            The water height. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.pixelsPerUnit">
            <summary>
            How many pixels should be in one unit of Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.segmentsPerUnit">
            <summary>
            The number of horizontal segments that should fit into one unit of Unity space.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.showMesh">
            <summary>
            Shows the water mesh shape in the Scene View.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.createCollider">
            <summary>
            Should we generate a collider on Start.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.colliderYAxisOffset">
            <summary>
            Colliders top edge offset.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.handlesPosition">
            <summary>
            A list with the local positions of the 4 handles (5 for 2.5D water). Do not change the handles order. 
            A lot of Water2D code will not work correctly if you change the order of the handles in the list. 
            0 - top handle.
            1 - bottom handle.
            2 - left handle.
            3 - right handle.
            4 (only for the 2.5D water) - the handle that controls the length of the horizontal mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.curentWaterArea">
            <summary>
            The value of this field is not used in any important calculations. When creating an animation that animates
            the area of the water, use this value as a guide to see how the water area changes between two positions.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.use3DCollider">
            <summary>
            It's used to decide what collider the water should have. A 2D or a 3D collider.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.overlapingSphereZOffset">
            <summary>
            The offset of the water's Box Collider on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.boxColliderZSize">
            <summary>
            The size of the water's Box Collider on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.handleScale">
            <summary>
            The scale of the handle gizmo.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.cubeWater">
            <summary>
            When set to true a horizontal mesh will be added to the vertical mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.zSize">
            <summary>
            The length on the Z axis the horizontal mesh has.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.frontMeshVertsCount">
            <summary>
            The number of vertices the water line has.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.waterHeight">
            <summary>
            The height of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.waterWidth">
            <summary>
            The width of the water.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.useHandles">
            <summary>
            When set to true the water size can be changed using a series of handles.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.prevSurfaceVertsCount">
            <summary>
            The number of vertices the water line has.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.xVerts">
            <summary>
            The number of horizontal vertices. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.yVerts">
            <summary>
            The number of vertical vertices. 
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.squareSegments">
            <summary>
            The front and top mesh will always be a quad.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.showMeshInfo">
            <summary>
            Displays in the inspector information about the front and top mesh.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.renderTextureWidth">
            <summary>
            The width af the render texture.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.renderTextureHeight">
            <summary>
            The height af the render texture.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.water2DRippleScript">
            <summary>
            Set to true if the current object has a Water2D_Ripple script attached to it.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.quadMesh">
            <summary>
            Should the front and top mesh be just a quad.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.zSegmentsCap">
            <summary>
            Should the number of segments on the Z axis be fixed.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.zSegmentsSize">
            <summary>
            The number of segments on the Z axis.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.topMeshGameObject">
            <summary>
            Reference to the game object that has the top mesh on it.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.boxColliderCenterOffset">
            <summary>
            BoxCollider center offset.
            </summary>
        </member>
        <member name="F:Water2DTool.Water2D_Tool.boxColliderSizeOffset">
            <summary>
            BoxCollider size offset.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.OnAwakeMeshRebuild">
            <summary>
            Creates a new mesh instance for the current object.
            This prevents objects instantiated using a prefab from having the same mesh instance.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.CheckComponentReference">
            <summary>
            Makes sure the references to different components are not null. 
            Checks it the current mesh points to the mesh of another object. 
            If so a new mesh instance is created for this object.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.RecalculateMeshParameters">
            <summary>
            Calculates water the width, height and length as well as other 
            variables that are necessary to build the water mesh.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.VertexLimit">
            <summary>
            Makes sure the mesh will not exceed the max number of vertices am single mesh can have.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateFrontMeshNoTiling">
            <summary>
            Generates the front mesh of the water. No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateFrontMeshDataNoTiling">
            <summary>
            Generates the front mesh vertices as well as the UV coordinates.
            No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GetFrontMeshUVNoTiling(System.Int32,System.Int32,UnityEngine.Vector2@)">
            <summary>
            Generates UV coordinates for a front mesh vertex.
            No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateTopMeshNoTiling">
            <summary>
            Generates the top mesh of the water. No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateTopMeshDataNoTiling">
            <summary>
            Generates the top mesh vertices as well as the UV coordinates.
            No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GetTopMeshUVWithoutTiling(System.Int32,System.Int32)">
            <summary>
            Calculates the UV coordinates of a vertex for ther top mesh. No texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateFrontMeshWithTiling">
            <summary>
            Generates the front mesh of the water. Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateFrontMeshDataWithTiling">
            <summary>
            Generates the front mesh vertices as well as the UV coordinates.
            Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GetFrontMeshUVWithTiling(UnityEngine.Vector3,System.Int32,System.Single)">
            <summary>
            Generates UV coordinates for a front mesh vertex.
            Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateTopMeshWithTiling">
            <summary>
            Generates the top mesh of the water. Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GenerateTopMeshDataWithTiling">
            <summary>
            Generates the top mesh vertices as well as the UV coordinates.
            Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GetTopMeshUVWithTiling(UnityEngine.Vector3,System.Int32,System.Single)">
            <summary>
            Calculates the UV coordinates of a vertex for ther top mesh. Texture tiling is applied.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.SetRenderTextureVariables">
            <summary>
            Recalculates the some parameters of the render texture.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.SetTopMeshUnitsPerUV">
            <summary>
            Calculates the number of pixels that should fix in one unit of unity space.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.UpdateCollider2D">
            <summary>
            Adds a BoxCollider2D component if the water doesn't have one and updates its size.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.UpdateCollider3D">
            <summary>
            Adds a BoxCollider component if the water doesn't have one and updates its size.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.GetMesh(System.Boolean)">
            <summary>
            Returns a mesh or adds a mesh if the object doesn't have one.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.UpdateWaterMesh(System.Single,System.Single,System.Boolean)">
            <summary>
            To be used when wanting to update the water properties externally.
            </summary>
            <param name="wWidth">Water width</param>
            <param name="wHeight">Water height</param>
            <param name="centerPos">When set to true recenters the pivot point</param>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.ReCenterPivotPoint">
            <summary>
            Moves the object location to the center of the handles. Also offsets the handles locations to match.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.Add(UnityEngine.Vector3)">
            <summary>
            Sets the position of a handle when the water is created.
            </summary>
            <param name="pos">Handle position</param>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.SetTopMeshMaterial">
            <summary>
            Sets the material for the horizontal mesh. This method is called only once when
            the toggle 2.5D Water is set to true in the inspector.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.SetDefaultMaterial">
            <summary>
            Sets the initial water material.
            </summary>
        </member>
        <member name="M:Water2DTool.Water2D_Tool.SetGPUWaterDefaultMaterial">
            <summary>
            Sets the initial water material.
            </summary>
        </member>
    </members>
</doc>
